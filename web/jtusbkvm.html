<!DOCTYPE html>
<!-- 

=========================================================================

JTUSBKVM - Web Console

Version: 1.4.0
Last Update: 2024-11-26

Author  : Jason Cheng
E-mail  : jason@jason.tools
GitHub  : https://github.com/jasoncheng7115
WebSite : https://blog.jason.tools , https://www.jason.tools 

License: GNU Affero General Public License v3.0
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
any later version.

=========================================================================

This software uses the following open source packages:

Xterm.js - https://github.com/xtermjs/xterm.js
License: MIT License
Copyright (c) 2014-2023, The xterm.js authors (https://github.com/xtermjs/xterm.js)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

=========================================================================

-->
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>JTUSBKVM - Jason Tools</title>
    <link rel="icon" type="image/png" sizes="512x512" href="logo-1.png">
    <link rel="stylesheet" href="js/xterm.css" />
    <script src="js/xterm.js"></script>
    <script src="js/xterm-addon-fit.js"></script>
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body, html {
            height: 100%;
            margin: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #header {
            display: flex;
            flex-direction: column;
            background: #f0f0f0;
            padding: 1px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            gap: 1px;
        }

        #titleContainer {
            display: flex;
            align-items: center;
            padding: 5px;
            border-bottom: 1px solid #ddd;
            margin-bottom: 5px;
        }

        #controls, #rightControls {
            display: inline-flex;  
            align-items: center;
            background: #e8e8e8;
            border-radius: 4px;
            padding: 5px;
            gap: 5px;
            flex: 0 0 auto;  
            white-space: nowrap;  /* Èò≤Ê≠¢ÂÖßÂÆπÊèõË°å */
        }
        #controlsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            width: 100%;
            background: #f0f0f0;
            padding: 0px;
        }
        #logo {
            height: 32px;
            margin-right: 10px;
        }
        #title {
            font-weight: bold;
            margin-right: 15px;
        }

        #rightControls .button-group {
            display: inline-flex;
            gap: 3px;
            align-items: center;
            flex-shrink: 0;
        }
        #rightControls {          
            display: inline-flex;
            align-items: center;
            background: #e8e8e8;
            border-radius: 4px;
            padding: 5px;
            gap: 5px;
        }
        #videoContainer {
            flex-grow: 1;
            position: relative;
            background: black;
            overflow: hidden;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #videoContainer.zoomed {
            overflow: auto;
            display: block; /* ‰øÆÊîπÁÇ∫ block ‰ª•ÊîØÊè¥Ê≠£Á¢∫ÁöÑÊç≤Âãï */
        }
        #showTerminal {
            margin-left: 15px;
            padding: 5px 15px;
            background-color: #2196F3; 
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #showTerminal:before {
            content: "üñ•Ô∏è"; 
            font-size: 14px;
        }

        #showTerminal:hover {
            background-color: #1976D2;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transform: translateY(-1px);
        }

        #showTerminal:active {
            background-color: #0D47A1;
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        #terminalWindow {
            position: absolute;
            width: 600px;
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            min-width: 400px;
            min-height: 36px;
            resize: both;       
            overflow: auto;     
            padding: 0;         
            box-shadow: rgba(0, 0, 0, 0.3) 0px 19px 38px, 
                        rgba(0, 0, 0, 0.22) 0px 15px 12px;
        }

        #terminalHeader {
            padding: 8px;
            background: #333;
            color: #fff; 
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 36px; 
        }


        #zoomControls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
        }

        #zoomControls button {
            padding: 5px 10px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #zoomControls button:hover:not(:disabled) {
            background-color: rgba(200, 200, 200, 0.7);
        }

        #zoomControls button:disabled {
            background-color: rgba(150, 150, 150, 0.7);
            cursor: not-allowed;
        }
        video {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            transition: width 0.3s, height 0.3s;
            display: block;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            outline: none;
            cursor: crosshair;
            z-index: 10;  /* Á¢∫‰øùË¶ÜËìãÂ±§Âú®ÊúÄ‰∏äÂ±§ */
        }
        select, button, input[type="text"] {
            height: 28px;
            padding: 0 8px;
            font-size: 12px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background: #fff;
            cursor: pointer;
        }
        button:hover, input[type="text"]:hover {
            background-color: #b0b0b0;
        }
        @keyframes buttonHighlight {
            0% { background-color: #e0e0e0; }
            50% { background-color: #ff9999; }
            100% { background-color: #e0e0e0; }
        }
        .highlight-button {
            animation: buttonHighlight 1s ease-in-out 3;  /* ÈñÉÁàç 3 Ê¨° */
        }
        .tooltip {
            position: absolute;
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1000;
            animation: fadeInOut 3s ease-in-out;
            white-space: nowrap;
        }

        .tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 0 8px 8px 8px;
            border-style: solid;
            border-color: transparent transparent #333 transparent;
        }

        /* Á∏ÆÊîæÊåáÁ§∫Âô®ÁöÑÊ®£Âºè */
        .zoom-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            color: white;
            font-size: 48px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 20px 40px;
            border-radius: 10px;
            opacity: 0;
            pointer-events: none; /* ‰ΩøÊåáÁ§∫Âô®‰∏çÊúÉÂΩ±ÈüøÊªëÈº†‰∫ã‰ª∂ */
            transition: opacity 0.5s ease, transform 0.5s ease;
            z-index: 20; /* Á¢∫‰øùÊåáÁ§∫Âô®Âú®Ë¶ñË®äÂíåË¶ÜËìãÂ±§‰πã‰∏ä */
        }

        /* È°ØÁ§∫ÊôÇÁöÑÊ®£Âºè */
        .zoom-indicator.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }
        @keyframes fadeInOut {
            0% { opacity: 0; }
            15% { opacity: 1; }
            85% { opacity: 1; }
            100% { opacity: 0; }
        }        

        .zoom-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
        }

        #videoContainer {
            position: relative;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background: black;
        }

        #videoContainer.zoomed {
            overflow: auto;
        }

        #video {
            display: block;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            cursor: crosshair;
            z-index: 10;
        }


        .toggle-button:hover {
            background-color: #909090;
        }
        .toggle-button.active:hover {
            background-color: #555555;
        }
        button:active, .toggle-button:active, input[type="text"]:active {
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-button {
            background-color: #e0e0e0;
        }
        .toggle-button.active {
            background-color: #a0a0a0;
            color: white;
        }
        button:disabled, input[type="text"]:disabled {
            opacity: 0.5;
            border-color: #ccc;
            cursor: not-allowed;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .button-group {
            display: inline-flex;  /* ÊîπÁÇ∫ inline-flex */
            gap: 3px;
            align-items: center;
            flex-shrink: 0;  /* Èò≤Ê≠¢ÊåâÈàïÁµÑË¢´Â£ìÁ∏Æ */
        }
  
        .separator {
            height: 28px;
            margin: 0 5px;
            border-left: 1px solid #ccc;
            flex-shrink: 0;
        }
        select, button {
            height: 28px;
            padding: 0 8px;
            font-size: 12px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .header-label {
            height: 32px;
            line-height: 32px;
            font-size: 14px;
            font-weight: bold; 
            flex-shrink: 0;  /* Èò≤Ê≠¢Ê®ôÁ±§Ë¢´Â£ìÁ∏Æ */
            white-space: nowrap;
        }
        .button-wrapper {
            display: flex;
            flex: 1;
            gap: 5px;
            flex-wrap: wrap;
            margin-left: auto;  /* Â∞áÊï¥ÂÄãÊåâÈàïÂçÄÊé®Âà∞Ê®ôÁ±§Âè≥ÂÅ¥ */
        }
        .terminal-label {
            line-height: 28px;
            margin: 0;
            padding: 0 5px;
            font-weight: bold;
            font-size: 12px;
            color: #fff;  /* Ê∑∫Ëâ≤ÊñáÂ≠óÔºåÁî®ÊñºÊ∑±Ëâ≤ËÉåÊôØ */
        }
        .terminal-controls button {
            width: 24px;          /* Âõ∫ÂÆöÊåâÈàïÂØ¨Â∫¶ */
            height: 24px;         /* Âõ∫ÂÆöÊåâÈàïÈ´òÂ∫¶ */
            line-height: 24px;    /* ÂûÇÁõ¥ÁΩÆ‰∏≠ */
            padding: 0;
            background: none;
            border: none;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .terminal-controls {
            display: flex;
            align-items: center;
            gap: 5px;  /* ÊåâÈàïÈñìË∑ù */
        }
        .terminal-controls button:hover {
            background: #444;
            border-radius: 3px;
        }

        #terminalContent {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: calc(100% - 36px);
            min-height: 250px;
        }
        #terminal-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin: 10px;  
            min-height: 0; 
            scrollbar-width: thin;
            scrollbar-color: #666 #1e1e1e;
        }
        #terminal-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        #terminal-container::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        #terminal-container::-webkit-scrollbar-thumb {
            background-color: #666;
            border-radius: 4px;
            border: 2px solid #1e1e1e;
        }

        #terminal-container::-webkit-scrollbar-thumb:hover {
            background-color: #888;
        }
        .header-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-icon {
            font-size: 16px;
        }
        .xterm {
            flex: 1;
            height: 100% !important;
        }
        #fnKeysPopup {
            display: none;
            position: absolute;
            background: #f0f0f0;
            border: 1px solid #000;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }
        #fnKeysPopup button {
            padding: 5px 10px;
            margin: 0;
            width: 100%;
        }
        #noVideoText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            display: none;
            z-index: 5;  /* Á¢∫‰øùÊñáÂ≠óÂú®Ë¶ñË®ä‰πã‰∏äÔºå‰ΩÜÂú®Ë¶ÜËìãÂ±§‰πã‰∏ã */
        }
        #recordingTime {
            display: none;
            margin: 0 8px;
            font-family: monospace;
            font-size: 12px;
            line-height: 28px;
            color: #ff0000;
            font-weight: bold;
            min-width: 70px;
        }
        #video:not([src]):not([srcObject]) + #overlay + #noVideoText {
            display: block;
        }
        @media (max-width: 768px) {
            #controls, #rightControls {
                width: 100%;
            }
            
            .button-group {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div id="header">
        <div id="titleContainer">
            <img id="logo" src="logo-1.png" alt="Logo">
            <div id="title">JTUSBKVM v1.4</div>
            <button id="showTerminal" title="ÈñãÂïüÁ∂≤Ë∑ØË£ùÁΩÆ Console Ë®≠ÂÆöÁµÇÁ´ØÊ©üÂäüËÉΩÔºåË®òÂæóÂ∞á RJ45 Á∑öÊé•‰∏äÁõÆÊ®ôË£ùÁΩÆÁöÑ Console ÈÄ£Êé•Âü†">Â∫èÂàóÁµÇÁ´ØÊ©ü</button>
        </div>
        <div id="controlsContainer">
            <div id="controls">
                <span class="header-label">ÊéßÂà∂</span>
                <div class="button-wrapper">
                    <div class="button-group">
                        <button id="connectController" title="ÈÄ£Êé•ÊéßÂà∂Âô®ÔºåÂÉÖÊîØÊè¥ Arduino Leonardo Êàñ Arduino Pro Micro">üü¢ ÈÄ£Êé•</button>
                        <button id="disconnectController" disabled>üî¥ ‰∏≠Êñ∑</button>
                    </div>
                    <div class="separator"></div>
                    <div class="button-group">
                        <button id="ctrlAltDelButton" disabled>Ctrl+Alt+Del</button>
                        <button id="fnButton" class="toggle-button" disabled>F1-F12</button>
                        <button id="winButton" class="toggle-button" disabled title="Windows Key / Super Key / Command Key">Win</button>
                        <button id="ctrlButton" class="toggle-button" disabled>Ctrl</button>
                        <button id="altButton" class="toggle-button" disabled>Alt</button>
                        <button id="releaseAllModifiers" class="toggle-button" disabled title="Â∞áÊâÄÊúâÁãÄÊÖãÁÇ∫Êåâ‰∏ãÁöÑ‰øÆÈ£æÈçµÈáãÊîæ">üîÑ ÈáãÊîæ</button>
                        <button id="pasteText" disabled title="Â∞á‰∏Ä‰∏≤ÊñáÂ≠óÊåá‰ª§Ë≤º‰∏äÔºå‰∏¶Âú®Ë¢´ÊéßÁ´Ø‰∏ªÊ©ü‰∏ä‰ª•Ê®°Êì¨ÈçµÁõ§ÊñπÂºèËº∏ÂÖ•">üìã Ë≤º‰∏ä</button>
                    </div>
                </div>
            </div>
        
            <div id="rightControls">
                <span class="header-label">Ë¶ñË®ä</span>
                <div class="button-wrapper">
                    <div class="button-group">
                        <select id="videoSource"></select>
                        <select id="resolution" title="Ëû¢ÂπïÊØî‰æãÔºåË´ãÈÅ∏ÊìáÁ¨¶ÂêàË¢´ÊéßÁ´ØÁöÑÊØî‰æãÔºå‰ª•ÈÅøÂÖçÁôºÁîüÊ∏∏Ê®ôÂÅèÁßªÂïèÈ°å">
                            <option value="1440x960" title="1440x960 / 1280x800">3:2</option>
                            <option value="1440x1080" title="1440x1080 / 1024x768 / 800x600">4:3</option>
                            <option value="1800x1080" title="1800x1080 / 1600x960 / 1280x768">5:3</option>
                            <option value="1280x1024" title="1280x1024">5:4</option>
                            <option value="1920x1080" title="1920x1080 / 1600x900 / 1366x768 / 1280x720" selected>16:9</option>
                            <option value="1680x1050" title="1680x1050 / 1600x1000 / 1440x900 / 1280x800">16:10</option>
                            <option value="1920x800" title="1920x800">21:9</option>
                        </select>
                        <button id="connectCapture" title="ÈÄ£Êé•Ë¶ñË®äÊì∑ÂèñÂô®ÔºåÂÉÖÊîØÊè¥ USB HDMI Capture Ë£ùÁΩÆ">‚ñ∂Ô∏è ÈÄ£Êé•</button>
                        <button id="disconnectCapture" disabled>‚èπÔ∏è ‰∏≠Êñ∑</button>
                    </div>
                    <div class="separator"></div>
                    <div class="button-group">   
                        <button id="zoomIn" title="ÊîæÂ§ßË¶ñË®äÁï´Èù¢ÊØî‰æãÔºåÊúÄÂ§ßËá≥ 300%">üîçÔºã</button>
                        <button id="zoomOut" disabled title="Á∏ÆÂ∞èË¶ñË®äÁï´Èù¢ÊØî‰æã">üîçÔºç</button>
                        <button id="screenshot" disabled title="Â∞áË¶ñË®äÁï´Èù¢Êì∑ÂèñÂúñÁâá‰∏¶‰∏ãËºâ">üñºÔ∏è Êì∑Âúñ</button>
                        <button id="startRecord" disabled title="ÈñãÂßãÂ∞áË¶ñË®äÁï´Èù¢ÈåÑÂΩ±">üî¥ ÈåÑÂΩ±</button>
                        <button id="stopRecord" disabled title="ÂÅúÊ≠¢Ë¶ñË®äÁï´Èù¢ÈåÑÂΩ±Ôºå‰∏¶‰∏ãËºâÂΩ±ÁâáÊ™î">‚¨õ ÂÅúÊ≠¢</button>
                        <span id="recordingTime" style="display: none;">00:00:00</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="fnKeysPopup">
        <button class="fn-key" data-key="F1">F1</button>
        <button class="fn-key" data-key="F2">F2</button>
        <button class="fn-key" data-key="F3">F3</button>
        <button class="fn-key" data-key="F4">F4</button>
        <button class="fn-key" data-key="F5">F5</button>
        <button class="fn-key" data-key="F6">F6</button>
        <button class="fn-key" data-key="F7">F7</button>
        <button class="fn-key" data-key="F8">F8</button>
        <button class="fn-key" data-key="F9">F9</button>
        <button class="fn-key" data-key="F10">F10</button>
        <button class="fn-key" data-key="F11">F11</button>
        <button class="fn-key" data-key="F12">F12</button>
    </div>

    <div id="pasteDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
    background: white; padding: 20px; border: 1px solid #000; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; 
    min-width: 500px; max-width: 80%;">
        <div style="margin-bottom: 10px; font-weight: bold;">ÊñáÂ≠óÂÇ≥ÈÄÅÂ∑•ÂÖ∑</div>
        <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-left: 4px solid #004085; font-size: 14px;">
            <p style="margin: 0 0 8px 0;">Ê≠§Â∑•ÂÖ∑ÊúÉÊ®°Êì¨ÈçµÁõ§Âú®ÁõÆÊ®ôÈõªËÖ¶‰∏äÈÄêÂ≠óËº∏ÂÖ•ÊñáÂ≠ó„ÄÇ</p>
            <p style="margin: 0 0 8px 0;">ÊîØÊè¥ÂÖßÂÆπÔºö</p>
            <ul style="margin: 0 0 8px 20px; padding: 0;">
                <li>Ëã±ÊñáÂ≠óÊØçÔºàÂ§ßÂ∞èÂØ´Ôºâ</li>
                <li>Êï∏Â≠ó</li>
                <li>Ê®ôÈªûÁ¨¶Ëôü</li>
                <li>Á©∫Ê†ºÂíåÊèõË°å</li>
            </ul>
            <p style="margin: 0; color: #dc3545;">Ê≥®ÊÑèÔºö‰∏çÊîØÊè¥‰∏≠Êñá„ÄÅÊó•Êñá„ÄÅÈüìÊñáÁ≠âÈùûËã±ÊñáÂ≠óÂÖÉ</p>
        </div>
        <div style="margin-bottom: 10px;">Ë´ãË≤º‰∏äË¶ÅÂÇ≥ÈÄÅÁöÑÊñáÂ≠óÔºö</div>
        <textarea id="pasteArea" rows="10" cols="50" style="width: 100%; margin-bottom: 10px; padding: 8px;"></textarea>
        <div id="pasteProgress" style="display: none; margin-bottom: 10px; padding: 8px; background: #e9ecef;">
            ÈÄ≤Â∫¶Ôºö<span id="pasteStatus">0</span>/<span id="pasteTotal">0</span> 
            (<span id="pastePercent">0</span>%)
        </div>
        <div style="display: flex; gap: 10px;">
            <button id="startPaste" style="padding: 5px 15px;">ÈñãÂßãÂÇ≥ÈÄÅ</button>
            <button id="pausePaste" style="padding: 5px 15px;">Êö´ÂÅú</button>
            <button id="cancelPaste" style="padding: 5px 15px;">ÂèñÊ∂à</button>
        </div>
    </div>

    <div id="videoContainer">
        <video id="video" autoplay muted></video>
        <div id="overlay" tabindex="0"></div>
        <div id="noVideoText">Â∞öÊú™ÈÄ£Êé•Ë¶ñË®ä‰æÜÊ∫ê</div>   
        <div id="zoomIndicator" class="zoom-indicator"></div>
    </div>

    <script>
        const connectControllerButton = document.getElementById('connectController');
        const disconnectControllerButton = document.getElementById('disconnectController');
        const connectCaptureButton = document.getElementById('connectCapture');
        const disconnectCaptureButton = document.getElementById('disconnectCapture');
        const video = document.getElementById('video');
        const videoSourceSelect = document.getElementById('videoSource');
        const resolutionSelect = document.getElementById('resolution');
        const overlay = document.getElementById('overlay');
        const ctrlAltDelButton = document.getElementById('ctrlAltDelButton');
        const winButton = document.getElementById('winButton');
        const ctrlButton = document.getElementById('ctrlButton');
        const altButton = document.getElementById('altButton');
        const fnButton = document.getElementById('fnButton');
        const releaseAllModifiersButton = document.getElementById('releaseAllModifiers');
        const fnKeysPopup = document.getElementById('fnKeysPopup');
        const screenshotButton = document.getElementById('screenshot');
        const startRecordButton = document.getElementById('startRecord');
        const stopRecordButton = document.getElementById('stopRecord');
        const recordingTimeDisplay = document.getElementById('recordingTime');
        const pressedModifiers = new Set();
        const modifierKeys = {
            ControlLeft: 'Control',
            ControlRight: 'Control',
            AltLeft: 'Alt',
            AltRight: 'Alt',
            MetaLeft: 'Meta',
            MetaRight: 'Meta',
            ShiftLeft: 'Shift',
            ShiftRight: 'Shift'
        };
        const pressedKeys = new Set();   
        const pasteTextButton = document.getElementById('pasteText');
        const pasteDialog = document.getElementById('pasteDialog');
        const pasteArea = document.getElementById('pasteArea');
        const startPasteButton = document.getElementById('startPaste');
        const pausePasteButton = document.getElementById('pausePaste');
        const cancelPasteButton = document.getElementById('cancelPaste');
        const pasteProgress = document.getElementById('pasteProgress');
        const pasteStatus = document.getElementById('pasteStatus');
        const pasteTotal = document.getElementById('pasteTotal');
        const pastePercent = document.getElementById('pastePercent');
        const keyboardMap = {
            'a': 'KeyA', 'b': 'KeyB', 'c': 'KeyC', 'd': 'KeyD', 'e': 'KeyE',
            'f': 'KeyF', 'g': 'KeyG', 'h': 'KeyH', 'i': 'KeyI', 'j': 'KeyJ',
            'k': 'KeyK', 'l': 'KeyL', 'm': 'KeyM', 'n': 'KeyN', 'o': 'KeyO',
            'p': 'KeyP', 'q': 'KeyQ', 'r': 'KeyR', 's': 'KeyS', 't': 'KeyT',
            'u': 'KeyU', 'v': 'KeyV', 'w': 'KeyW', 'x': 'KeyX', 'y': 'KeyY',
            'z': 'KeyZ',
            '1': 'Digit1', '2': 'Digit2', '3': 'Digit3', '4': 'Digit4', '5': 'Digit5',
            '6': 'Digit6', '7': 'Digit7', '8': 'Digit8', '9': 'Digit9', '0': 'Digit0',
            '-': 'Minus', '=': 'Equal',
            '[': 'BracketLeft', ']': 'BracketRight',
            '\\': 'Backslash',
            ';': 'Semicolon', "'": 'Quote',
            ',': 'Comma', '.': 'Period',
            '/': 'Slash', '`': 'Backquote',
            ' ': 'Space'
        };
        const needsShift = new Set([
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
            '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+',
            '{', '}', '|', ':', '"', '<', '>', '?'
        ]);
        const WHEEL_DELAY = 50; // Âª∂ÈÅ≤ 50ms
        const ZOOM_STEP = 0.25;
        const ZOOM_MAX = 3; // ÊúÄÂ§ßÊîæÂ§ßÂÄçÁéá 300%
        const ZOOM_MIN = 1; // ÊúÄÂ∞èÊîæÂ§ßÂÄçÁéá 100%
        const zoomInButton = document.getElementById('zoomIn');
        const zoomOutButton = document.getElementById('zoomOut');
        const videoContainer = document.getElementById('videoContainer');
        const videoElement = document.getElementById('video');
        const overlayElement = document.getElementById('overlay');
        // ÂÆöÁæ©ÊèõË°åÊ®°Âºè
        const LINE_ENDING_MODES = {
            CRLF: '\r\n',
            CR: '\r',
            LF: '\n'
        };

        
        let currentLineEnding = LINE_ENDING_MODES.CRLF; // È†êË®≠‰ΩøÁî® CRLF
        let currentZoom = 1;
        let videoStream;
        let port;
        let writer;
        let isPasting = false;
        let isPausePasting = false;
        let currentPasteIndex = 0;
        let textToSend = '';
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingTimer = null;
        let recordingStartTime = null;
        let keyEventListener = null;
        let mouseMoveListener = null;
        let mouseClickListener = null; 
        let lastMouseX = null;
        let lastMouseY = null;
        let lastConsoleLogTime = 0;
        let isFnPopupVisible = false;
        let lastWheelTime = 0;
        let sharedReader = null;
        let isReading = true;  

        async function sendCtrlAltDel() {
            if (writer) {
                try {
                    // Áõ¥Êé•ÂÇ≥ÈÄÅÁâπÂÆöÁöÑ Ctrl+Alt+Del ÂëΩ‰ª§
                    await writer.write(new TextEncoder().encode('B:CTRL_ALT_DEL\n'));
                    console.log('Â∑≤ÂÇ≥ÈÄÅ Ctrl+Alt+Delete ÂëΩ‰ª§');
                } catch (error) {
                    console.error('ÂÇ≥ÈÄÅ Ctrl+Alt+Delete ÊôÇÁôºÁîüÈåØË™§:', error);
                }
            }
        }

        // ÊîæÂ§ßÂáΩÊï∏
        function zoomIn() {
            if (currentZoom < ZOOM_MAX) {
                currentZoom += ZOOM_STEP;
                applyZoom();
                showZoomIndicator(); // È°ØÁ§∫Á∏ÆÊîæÊåáÁ§∫Âô®
            }
        }

        // Á∏ÆÂ∞èÂáΩÊï∏
        function zoomOut() {
            if (currentZoom > ZOOM_MIN) {
                currentZoom -= ZOOM_STEP;
                applyZoom();
                showZoomIndicator(); // È°ØÁ§∫Á∏ÆÊîæÊåáÁ§∫Âô®
            }
        }

        // Â•óÁî®ÊîæÂ§ßÁ∏ÆÂ∞èÊïàÊûú
        function applyZoom() {
            const videoWidth = video.videoWidth * currentZoom;
            const videoHeight = video.videoHeight * currentZoom;
            
            // Ë®≠ÂÆöË¶ñË®äÂíåÈÅÆÁΩ©Â±§ÁöÑËÆäÊèõ
            videoElement.style.transform = `scale(${currentZoom})`;
            overlayElement.style.transform = `scale(${currentZoom})`;
            
            // Ë®≠ÂÆöËÆäÊèõÂéüÈªûÁÇ∫Â∑¶‰∏äËßí
            videoElement.style.transformOrigin = '0 0';
            overlayElement.style.transformOrigin = '0 0';
            
            // Ë®àÁÆóÊîæÂ§ßÂæåÁöÑÂ∞∫ÂØ∏
            const scaledWidth = Math.max(video.videoWidth * currentZoom, video.videoWidth);
            const scaledHeight = Math.max(video.videoHeight * currentZoom, video.videoHeight);
            
            if (currentZoom > 1) {
                // ÂïüÁî®Êç≤ÂãïÊ¢ù
                videoContainer.style.overflow = 'auto';
                
                // Âª∫Á´ãÊàñÂèñÂæóÂåÖË£ùÂô®
                let wrapper = videoContainer.querySelector('.zoom-wrapper');
                if (!wrapper) {
                    wrapper = document.createElement('div');
                    wrapper.className = 'zoom-wrapper';
                    // Â∞áÁèæÊúâÂÖÉÁ¥†ÁßªÂãïÂà∞ÂåÖË£ùÂô®‰∏≠
                    while (videoContainer.firstChild) {
                        wrapper.appendChild(videoContainer.firstChild);
                    }
                    videoContainer.appendChild(wrapper);
                }
                
                // Ë®≠ÂÆöÂåÖË£ùÂô®ÁöÑÂ∞∫ÂØ∏ÁÇ∫ÊîæÂ§ßÂæåÁöÑÂØ¶ÈöõÂ∞∫ÂØ∏
                wrapper.style.width = `${scaledWidth}px`;
                wrapper.style.height = `${scaledHeight}px`;
                wrapper.style.position = 'absolute';
                wrapper.style.left = '0';
                wrapper.style.top = '0';
                
                // Á¢∫‰øùË¶ñË®äÂíåÈÅÆÁΩ©Â±§Â°´ÊªøÂåÖË£ùÂô®
                videoElement.style.position = 'absolute';
                overlayElement.style.position = 'absolute';
                videoElement.style.width = `${video.videoWidth}px`;
                videoElement.style.height = `${video.videoHeight}px`;
                overlayElement.style.width = `${video.videoWidth}px`;
                overlayElement.style.height = `${video.videoHeight}px`;
                
                // Êõ¥Êñ∞ÂÆπÂô®È°ûÂà•
                videoContainer.classList.add('zoomed');
            } else {
                // Á∏ÆÊîæÊØî‰æãÁÇ∫ 1 ÊôÇÔºåÈÇÑÂéüÊâÄÊúâË®≠ÂÆö
                videoContainer.style.overflow = 'hidden';
                videoContainer.style.display = 'flex';  // ÈáçË¶ÅÔºöÊÅ¢Âæ©ÁÇ∫ flex Â∏ÉÂ±Ä
                
                const wrapper = videoContainer.querySelector('.zoom-wrapper');
                if (wrapper) {
                    while (wrapper.firstChild) {
                        videoContainer.appendChild(wrapper.firstChild);
                    }
                    wrapper.remove();
                }
                
                // ÈáçË®≠Ë¶ñË®äÂíåÈÅÆÁΩ©Â±§ÁöÑÊ®£Âºè
                videoElement.style.position = 'relative';
                overlayElement.style.position = 'absolute';
                videoElement.style.width = '100%';
                videoElement.style.height = '100%';
                videoElement.style.maxWidth = '100%';  // Á¢∫‰øùË¶ñË®ä‰∏çÊúÉË∂ÖÂá∫ÂÆπÂô®
                videoElement.style.maxHeight = '100%';
                videoElement.style.transform = 'none';  // ÁßªÈô§Á∏ÆÊîæËÆäÊèõ
                overlayElement.style.transform = 'none';
                
                // ÊÅ¢Âæ©ÂéüÂßãÁöÑ object-fit Ë®≠ÂÆö
                videoElement.style.objectFit = 'contain';
                
                // ÁßªÈô§ÂÆπÂô®È°ûÂà•
                videoContainer.classList.remove('zoomed');
            }
            
            // Êõ¥Êñ∞Á∏ÆÊîæÊåâÈàïÁãÄÊÖã
            zoomInButton.disabled = currentZoom >= ZOOM_MAX;
            zoomOutButton.disabled = currentZoom <= ZOOM_MIN;
        }


        // Êì∑ÂúñÂäüËÉΩ
        async function takeScreenshot() {
            if (video.srcObject) {
                try {
                    // Âª∫Á´ã canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    // Âú® canvas ‰∏äÁπ™Ë£ΩÁõÆÂâçË¶ñË®äÁï´Èù¢
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // ËΩâÊèõÁÇ∫ blob
                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/png');
                    });
                    
                    // Âª∫Á´ã‰∏ãËºâÈÄ£Áµê
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `screenshot_${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('Êì∑ÂúñÊôÇÁôºÁîüÈåØË™§:', error);
                    alert('Êì∑ÂúñÂ§±ÊïóÔºåË´ãÈáçË©¶');
                }
            }
        }


        // Ê™¢Êü•ÊòØÂê¶ÂåÖÂê´‰∏≠Êó•ÈüìÊñáÂ≠ó
        function containsCJK(text) {
            // Unicode ÁØÑÂúçÔºö
            // ‰∏≠ÊñáÔºö\u4e00-\u9fff
            // Êó•ÊñáÂÅáÂêçÔºö\u3040-\u309f\u30a0-\u30ff
            // ÈüìÊñáÔºö\uac00-\ud7af\u1100-\u11ff
            const cjkRegex = /[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af\u1100-\u11ff]/;
            return cjkRegex.test(text);
        }

        // È°ØÁ§∫Á∏ÆÊîæÊåáÁ§∫Âô®
        function showZoomIndicator() {
            const zoomIndicator = document.getElementById('zoomIndicator');
            zoomIndicator.textContent = `${Math.round(currentZoom * 100)}%`;
            zoomIndicator.classList.add('show');
            
            // Ê∏ÖÈô§‰πãÂâçÁöÑË®àÊôÇÂô®ÔºàÂ¶ÇÊûúÊúâÁöÑË©±Ôºâ
            if (zoomIndicator.timeoutId) {
                clearTimeout(zoomIndicator.timeoutId);
            }
            
            // Ë®≠ÁΩÆË®àÊôÇÂô®ÔºåÂú®ÂπæÁßíÂæåÈö±ËóèÊåáÁ§∫Âô®
            zoomIndicator.timeoutId = setTimeout(() => {
                zoomIndicator.classList.remove('show');
            }, 2000); // È°ØÁ§∫ 2 Áßí
        }


        // ÈñãÂßãÈåÑÂΩ±
        function startRecording() {
            try {
                recordedChunks = [];
                const options = { 
                    mimeType: 'video/mp4;codecs=h264,aac'  // ÂòóË©¶‰ΩøÁî® MP4
                };

                // Â¶ÇÊûúÁÄèË¶ΩÂô®‰∏çÊîØÊè¥ MP4 ÈåÑË£ΩÔºåÂõûÂà∞ WebM
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    console.log('MP4 Ê†ºÂºè‰∏çÊîØÊè¥Ôºå‰ΩøÁî® WebM');
                    options.mimeType = 'video/webm;codecs=vp9';
                }

                mediaRecorder = new MediaRecorder(video.srcObject, options);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = saveRecording;
                
                mediaRecorder.start();
                startRecordButton.disabled = true;
                stopRecordButton.disabled = false;
                console.log('ÈñãÂßãÈåÑÂΩ±');

                // Ë®≠ÂÆöÈåÑÂΩ±ÈñãÂßãÊôÇÈñì
                recordingStartTime = Date.now();

                // È°ØÁ§∫ÈåÑÂΩ±ÊôÇÈñì
                recordingTimeDisplay.style.display = 'inline'; // Êàñ 'block' Ê†πÊìöÊÇ®ÁöÑÈúÄÊ±Ç

                // ÂàùÂßãÂåñÈåÑÂΩ±ÊôÇÈñìÈ°ØÁ§∫
                updateRecordingTime();

                // ÂïüÂãïÂÆöÊôÇÂô®ÔºåÊØèÁßíÊõ¥Êñ∞‰∏ÄÊ¨°ÈåÑÂΩ±ÊôÇÈñì
                recordingTimer = setInterval(updateRecordingTime, 1000);

            } catch (error) {
                console.error('ÈñãÂßãÈåÑÂΩ±ÊôÇÁôºÁîüÈåØË™§:', error);
                alert('ÈñãÂßãÈåÑÂΩ±Â§±ÊïóÔºåË´ãÈáçË©¶');
            }
        }



        function highlightConnectController() {
            if (!connectControllerButton.classList.contains('highlight-button')) {
                
                // Â¢ûÂä†ÈñÉÁàçÊïàÊûú
                connectControllerButton.classList.add('highlight-button');
                
                // Âª∫Á´ãÊèêÁ§∫Ê°Ü
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.textContent = 'Ë´ãÂÖàÈÄ£Êé•ÊéßÂà∂Âô®ÊâçËÉΩ‰ΩøÁî®ÈçµÁõ§ÊªëÈº†ÂäüËÉΩÔºÅ';
                
                // Ë®àÁÆó‰ΩçÁΩÆ
                const buttonRect = connectControllerButton.getBoundingClientRect();
                tooltip.style.left = `${buttonRect.left + (buttonRect.width / 2)}px`;
                tooltip.style.top = `${buttonRect.bottom + 10}px`;
                tooltip.style.transform = 'translateX(-50%)';
                
                // Âä†ÂÖ•Âà∞ body ‰∏≠
                document.body.appendChild(tooltip);
                
                // Ë®≠ÂÆöÊôÇÂô®ÁßªÈô§ÊïàÊûú
                setTimeout(() => {
                    connectControllerButton.classList.remove('highlight-button');
                    document.body.removeChild(tooltip);
                }, 3000);
            }
        }

        function checkControllerAndHighlight(event) {
            if (!port && video.srcObject) {  // Â¶ÇÊûúÊ≤íÊúâÈÄ£Êé•ÊéßÂà∂Âô®‰ΩÜÊúâË¶ñË®ä
                event.preventDefault();  // ÈòªÊ≠¢È†êË®≠Ë°åÁÇ∫
                highlightConnectController();
            }
        }

        function updateRecordingTime() {
            const elapsedTime = Date.now() - recordingStartTime;
            const totalSeconds = Math.floor(elapsedTime / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            recordingTimeDisplay.textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // ÂÅúÊ≠¢ÈåÑÂΩ±
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                startRecordButton.disabled = false;
                stopRecordButton.disabled = true;
                console.log('ÂÅúÊ≠¢ÈåÑÂΩ±');

                // ÂÅúÊ≠¢ÂÆöÊôÇÂô®
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }

                // Èö±ËóèÈåÑÂΩ±ÊôÇÈñì
                recordingTimeDisplay.style.display = 'none';

                // ÈáçÁΩÆÈåÑÂΩ±ÈñãÂßãÊôÇÈñì
                recordingStartTime = null;

                // ÈáçÁΩÆÈåÑÂΩ±ÊôÇÈñìÈ°ØÁ§∫ÂÖßÂÆπÔºàÂèØÈÅ∏Ôºâ
                recordingTimeDisplay.textContent = '00:00:00';
            }
        }


        // ÂÑ≤Â≠òÈåÑÂΩ±
        function saveRecording() {
            try {
                const mimeType = mediaRecorder.mimeType;
                const blob = new Blob(recordedChunks, { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // Âà§Êñ∑Ê™îÊ°àÊ†ºÂºè
                const fileExt = mimeType.includes('mp4') ? 'mp4' : 'webm';
                a.download = `recording_${new Date().toISOString().replace(/[:.]/g, '-')}.${fileExt}`;
                
                if (fileExt === 'webm') {
                    alert('Áî±ÊñºÁÄèË¶ΩÂô®ÈôêÂà∂ÔºåÂΩ±ÁâáÂ∑≤ÂÑ≤Â≠òÁÇ∫ WebM Ê†ºÂºè„ÄÇÂ¶ÇÈúÄ MP4 Ê†ºÂºèÔºåË´ã‰ΩøÁî®ÂΩ±ÁâáËΩâÊ™îËªüÈ´îÈÄ≤Ë°åËΩâÊèõ„ÄÇ');
                }
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                recordedChunks = [];
            } catch (error) {
                console.error('ÂÑ≤Â≠òÈåÑÂΩ±ÊôÇÁôºÁîüÈåØË™§:', error);
                alert('ÂÑ≤Â≠òÈåÑÂΩ±Â§±ÊïóÔºåË´ãÈáçË©¶');
            }
        }

        function stopVideoStream() {
            if (videoStream) {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    stopRecording();
                    clearInterval(recordingTimer);
                    recordingTimeDisplay.style.display = 'none';
                }
                videoStream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                videoStream = null;
                document.getElementById('noVideoText').style.display = 'block';
            }
            connectCaptureButton.disabled = false;
            disconnectCaptureButton.disabled = true;
            screenshotButton.disabled = true;       
            startRecordButton.disabled = true;      
            stopRecordButton.disabled = true;       
            pasteTextButton.disabled = true;
        }

        // ÂèñÂæóË¶ñË®äË£ùÁΩÆÊ∏ÖÂñÆ
        async function getVideoSources() {
            try {
                // ÂÖàË´ãÊ±ÇÊ¨äÈôê
                await navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        // ÂèñÂæóÊ¨äÈôêÂæåÁ´ãÂç≥ÂÅúÊ≠¢stream
                        stream.getTracks().forEach(track => track.stop());
                    });
                    
                // ‰πãÂæåÂÜçÂàóËàâË®≠ÂÇô
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => {
                    if (device.kind === 'videoinput') {
                        const label = device.label.toUpperCase();
                        return (label.startsWith('USB') && 
                            /\d\.?\s*\d/.test(label) && 
                            (label.includes('HD') || label.includes('CAPTURE')));
                    }
                    return false;
                });

                if (videoDevices.length === 0) {
                    // Ê≤íÊúâÁ¨¶ÂêàÁöÑË£ùÁΩÆ
                    videoSourceSelect.innerHTML = '<option value="">ÁÑ°Â∞çÊáâË£ùÁΩÆ</option>';
                    // ÂÅúÁî®ÊâÄÊúâË¶ñË®äÁõ∏ÈóúÊåâÈàï
                    connectCaptureButton.disabled = true;
                    disconnectCaptureButton.disabled = true;
                    screenshotButton.disabled = true;
                    startRecordButton.disabled = true;
                    stopRecordButton.disabled = true;
                    resolutionSelect.disabled = true;
                } else {
                    videoSourceSelect.innerHTML = videoDevices.map(device => {
                        let label = device.label || 'Ë¶ñË®ä‰æÜÊ∫ê';
                        label = label.replace(/\(.*?\)/g, '').trim();
                        return `<option value="${device.deviceId}">${label}</option>`;
                    }).join('');

                    // ÂïüÁî®Ë¶ñË®äÈÄ£Êé•ÊåâÈàïÂíåËß£ÊûêÂ∫¶ÈÅ∏Êìá
                    connectCaptureButton.disabled = false;
                    resolutionSelect.disabled = false;

                    const savedVideoSource = localStorage.getItem('videoSourceId');
                    const savedResolution = localStorage.getItem('resolution');

                    if (savedVideoSource && videoDevices.some(device => device.deviceId === savedVideoSource)) {
                        videoSourceSelect.value = savedVideoSource;
                    }

                    if (savedResolution) {
                        resolutionSelect.value = savedResolution;
                    }
                }
            } catch (error) {
                console.error('ÂèñÂæóË¶ñË®ä‰æÜÊ∫êÊôÇÁôºÁîüÈåØË™§:', error);
                alert('Ë´ãÂÖÅË®±Ë¶ñË®äÊ¨äÈôê‰ª•‰ΩøÁî®Ê≠§ÂäüËÉΩ');
            }
        }

        async function startVideoStream() {
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            const selectedDeviceId = videoSourceSelect.value;
            const [width, height] = resolutionSelect.value.split('x').map(Number);

            const constraints = {
                video: {
                    deviceId: { exact: selectedDeviceId },
                    width: { exact: width },  // ‰øùÊåÅ exact ‰ª•Á¢∫‰øùÂèñÂæóÊ≠£Á¢∫ÁöÑËß£ÊûêÂ∫¶
                    height: { exact: height }
                }
            };

            try {
                videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = videoStream;
                document.getElementById('noVideoText').style.display = 'none'; 

                video.onloadedmetadata = () => {
                    connectCaptureButton.disabled = true;
                    disconnectCaptureButton.disabled = false;
                    screenshotButton.disabled = false;      
                    startRecordButton.disabled = false;     
                    stopRecordButton.disabled = true;       

                    localStorage.setItem('videoSourceId', selectedDeviceId);
                    localStorage.setItem('resolution', resolutionSelect.value);
                };
            } catch (error) {
                console.error('ÈñãÂßãË¶ñË®ä‰∏≤ÊµÅÊôÇÁôºÁîüÈåØË™§:', error);
                
                if (error.name === 'OverconstrainedError') {
                    // ÂëäÁü•Áî®Êà∂ÁõÆÂâçËß£ÊûêÂ∫¶‰∏çÊîØÊè¥
                    alert(`Ê≠§Ë£ùÁΩÆ‰∏çÊîØÊè¥ ${width}x${height} Ëß£ÊûêÂ∫¶`);
                    
                    // ÂòóË©¶ÂàáÊèõÂà∞ËºÉ‰ΩéÁöÑËß£ÊûêÂ∫¶
                    const resolutions = ['1920x1080', '1366x768', '1280x720'];
                    let foundSupportedResolution = false;

                    for (const res of resolutions) {
                        if (res === resolutionSelect.value) continue; // Ë∑≥ÈÅéÂ§±ÊïóÁöÑËß£ÊûêÂ∫¶
                        
                        resolutionSelect.value = res;
                        const [newWidth, newHeight] = res.split('x').map(Number);
                        
                        try {
                            const newConstraints = {
                                video: {
                                    deviceId: { exact: selectedDeviceId },
                                    width: { exact: newWidth },
                                    height: { exact: newHeight }
                                }
                            };
                            
                            videoStream = await navigator.mediaDevices.getUserMedia(newConstraints);
                            video.srcObject = videoStream;
                            document.getElementById('noVideoText').style.display = 'none';
                            
                            connectCaptureButton.disabled = true;
                            disconnectCaptureButton.disabled = false;
                            screenshotButton.disabled = false;
                            startRecordButton.disabled = false;
                            stopRecordButton.disabled = true;
                            
                            localStorage.setItem('videoSourceId', selectedDeviceId);
                            localStorage.setItem('resolution', res);
                            
                            foundSupportedResolution = true;
                            alert(`Â∑≤Ëá™ÂãïÂàáÊèõÂà∞ÊîØÊè¥ÁöÑËß£ÊûêÂ∫¶: ${res}`);
                            break;
                        } catch (e) {
                            console.error(`Ëß£ÊûêÂ∫¶ ${res} ‰πü‰∏çÊîØÊè¥:`, e);
                        }
                    }
                    
                    if (!foundSupportedResolution) {
                        alert('ÁÑ°Ê≥ïÊâæÂà∞ÊîØÊè¥ÁöÑËß£ÊûêÂ∫¶ÔºåË´ãÊâãÂãïÈÅ∏ÊìáÂÖ∂‰ªñËß£ÊûêÂ∫¶Ë©¶Ë©¶„ÄÇ');
                    }
                } else if (error.name === 'NotAllowedError') {
                    alert('Ë´ãÂÖÅË®±Ë¶ñË®äÊ¨äÈôê‰ª•‰ΩøÁî®Ê≠§ÂäüËÉΩ');
                } else if (error.name === 'NotFoundError') {
                    alert('Êâæ‰∏çÂà∞ÊåáÂÆöÁöÑË¶ñË®äË£ùÁΩÆ');
                } else if (error.name === 'NotReadableError') {
                    alert('ÁÑ°Ê≥ïÂ≠òÂèñË¶ñË®äË£ùÁΩÆÔºåÂèØËÉΩË¢´ÂÖ∂‰ªñÁ®ãÂºè‰ΩîÁî®');
                } else {
                    alert('Ë¶ñË®äÂïüÂãïÂ§±ÊïóÔºö' + error.message);
                }
            }
        }
            
    
        async function connectController() {
            if ('serial' in navigator) {
                try {
                    const filters = [{
                        usbVendorId: 0x2341,
                        usbProductId: 0x8036
                    }];

                    port = await navigator.serial.requestPort({ filters });
                    await port.open({ baudRate: 115200 });

                    connectControllerButton.disabled = true;
                    disconnectControllerButton.disabled = false;

                    addEventListeners();
                    overlay.focus();

                    ctrlAltDelButton.disabled = false;
                    winButton.disabled = false;
                    ctrlButton.disabled = false;
                    altButton.disabled = false;
                    fnButton.disabled = false;
                    releaseAllModifiersButton.disabled = false;
                    pasteTextButton.disabled = false;


                    // Êõ¥Êñ∞ÁµÇÁ´ØÊ©üÊåâÈàïÁãÄÊÖãÔºå‰ΩÜ‰øùÊåÅÊèõË°åÊ®°ÂºèÂèØÈÅ∏
                    updateTerminalButtonStates(true);
                            
                    // Á¢∫‰øùÊèõË°åÊ®°ÂºèÈÅ∏ÊìáÂô®‰øùÊåÅÂïüÁî®
                    const lineEndingMode = document.getElementById('lineEndingMode');
                    if (lineEndingMode) {
                        lineEndingMode.disabled = false;
                    }

                } catch (error) {
                    console.error('ÈÄ£Êé•ÊéßÂà∂Âô®ÊôÇÁôºÁîüÈåØË™§:', error);
                    
                    // Ê†πÊìöÈåØË™§È°ûÂûãÈ°ØÁ§∫‰∏çÂêåË®äÊÅØ
                    if (error.name === 'NetworkError') {
                        alert('ÁÑ°Ê≥ïÈñãÂïüÂ∫èÂàóÂü†ÔºåÂèØËÉΩË¢´ÂÖ∂‰ªñÁ®ãÂºè‰ΩîÁî®‰∏≠„ÄÇË´ãÈóúÈñâÂÖ∂‰ªñ‰ΩøÁî®Ê≠§Ë£ùÁΩÆÁöÑÁ®ãÂºèÂæåÂÜçË©¶„ÄÇ');
                    } else {
                        alert('ÈÄ£Êé•ÊéßÂà∂Âô®ÊôÇÁôºÁîüÈåØË™§: ' + error.message);
                    }
                }
            } else {
                alert('ÊÇ®ÁöÑÁÄèË¶ΩÂô®‰∏çÊîØÊè¥ Web Serial API');
            }
        }
    
     
        async function disconnectController() {
            
            isReading = false;

            await new Promise(resolve => setTimeout(resolve, 100));

            if (writer) {
                try {
                    // ‰∏≠Êñ∑ÂâçÂÇ≥ÈÄÅ RELEASE_ALL
                    await writer.write(new TextEncoder().encode('B:RELEASE_ALL\n'));
                    writer.releaseLock();
                } catch (error) {
                    console.error('ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§ÊôÇÁôºÁîüÈåØË™§:', error);
                }
                writer = null;
            }

            try {
                if (sharedReader) {
                    await sharedReader.cancel();
                    if (sharedReader.locked) {
                        sharedReader.releaseLock();
                    }
                    sharedReader = null;
                }

                if (port) {
                    await port.close();
                    port = null;
                }
            } catch (error) {
                console.error('ÈóúÈñâÈÄ£Êé•ÊôÇÁôºÁîüÈåØË™§:', error);
            }

            // ÈáçÁΩÆÊâÄÊúâÊåâÈàïÁãÄÊÖã
            connectControllerButton.disabled = false;
            disconnectControllerButton.disabled = true;

            removeEventListeners();
            await resetButtonStates();

            ctrlAltDelButton.disabled = true;
            winButton.disabled = true;
            ctrlButton.disabled = true;
            altButton.disabled = true;
            fnButton.disabled = true;
            releaseAllModifiersButton.disabled = true;
            pasteTextButton.disabled = true;

            // Êõ¥Êñ∞ÁµÇÁ´ØÊ©üÁöÑÊåâÈàïÁãÄÊÖã
            const terminalConnect = document.getElementById('terminalConnect');
            const terminalClear = document.getElementById('terminalClear');
            const terminalBaudRate = document.getElementById('terminalBaudRate');

            if (terminalConnect) terminalConnect.disabled = false;
            if (terminalClear) terminalClear.disabled = true;
            if (terminalBaudRate) terminalBaudRate.disabled = false;

            // Â¶ÇÊûúÁµÇÁ´ØÊ©üÂ∑≤Á∂ìÊâìÈñãÔºåÊõ¥Êñ∞ÂÖ∂ÁãÄÊÖã
            if (window.term) {
                term.writeln('Disconnected from serial port');
            }

            closeFnPopup();
            lastMouseX = null;
            lastMouseY = null;
            }


    
        function addEventListeners() {
            keyEventListener = (event) => sendKeyToArduino(event);
            overlay.addEventListener('keydown', keyEventListener);
            overlay.addEventListener('keyup', keyEventListener);
    
            mouseMoveListener = (event) => sendMouseMovementToArduino(event);
            overlay.addEventListener('mousemove', mouseMoveListener);
    
            mouseClickListener = (event) => sendMouseClickToArduino(event);
            overlay.addEventListener('mousedown', mouseClickListener);
            overlay.addEventListener('mouseup', mouseClickListener);
            
            overlay.addEventListener('wheel', handleMouseWheel);

           
            ctrlAltDelButton.addEventListener('click', sendCtrlAltDel);
            winButton.addEventListener('click', toggleWinKey);
            ctrlButton.addEventListener('click', toggleCtrlKey);
            altButton.addEventListener('click', toggleAltKey);
            fnButton.addEventListener('click', toggleFnKeys);
            releaseAllModifiersButton.addEventListener('click', releaseAllModifiers);
    
            pasteTextButton.addEventListener('click', () => {
                pasteDialog.style.display = 'block';
                pasteArea.value = '';
                pasteProgress.style.display = 'none';
                isPasting = false;
                isPausePasting = false;
            });

            cancelPasteButton.addEventListener('click', () => {
                pasteDialog.style.display = 'none';
                if (isPasting) {
                    isPasting = false;
                    isPausePasting = false;
                }
            });

            pausePasteButton.addEventListener('click', () => {
                if (isPasting) {
                    isPausePasting = !isPausePasting;
                    pausePasteButton.textContent = isPausePasting ? 'ÁπºÁ∫å' : 'Êö´ÂÅú';
                }
            });

            startPasteButton.addEventListener('click', async () => {
                if (!port) {
                    alert('Ë´ãÂÖàÈÄ£Êé•ÊéßÂà∂Âô®');
                    return;
                }

                textToSend = pasteArea.value;
                if (!textToSend) {
                    alert('Ë´ãËº∏ÂÖ•Ë¶ÅÂÇ≥ÈÄÅÁöÑÊñáÂ≠ó');
                    return;
                }

                // Ê™¢Êü•ÊòØÂê¶ÂåÖÂê´‰∏≠Êó•ÈüìÊñáÂ≠ó
                if (containsCJK(textToSend)) {
                    if (!confirm('Ê™¢Ê∏¨ÊñáÂ≠ó‰∏≠ÂåÖÂê´‰∏≠Êñá„ÄÅÊó•ÊñáÊàñÈüìÊñáÂ≠óÂÖÉÔºåÈÄô‰∫õÂ≠óÂÖÉÂ∞áÁÑ°Ê≥ïÊ≠£Á¢∫ÂÇ≥ÈÄÅ„ÄÇ\n\nË¶ÅÁπºÁ∫åÂÇ≥ÈÄÅÂóéÔºüÔºà‰∏çÊîØÊè¥ÁöÑÂ≠óÂÖÉÂ∞áË¢´Ë∑≥ÈÅéÔºâ')) {
                        return;
                    }
                }

                if (!isPasting) {
                    isPasting = true;
                    currentPasteIndex = 0;
                    pasteProgress.style.display = 'block';
                    pasteTotal.textContent = textToSend.length;
                    startPasteButton.disabled = true;
                    pasteArea.disabled = true;

                    sendTextByChar();
                }
            });

            overlay.addEventListener('mouseleave', handleMouseLeave);
    

            overlay.addEventListener('keydown', (event) => {
                // Windows ÁöÑ Ctrl + A
                // macOS ÁöÑ Command + A (metaKey)
                if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'a') {
                    event.preventDefault();
                    console.log('ÈòªÊ≠¢ÂÖ®ÈÅ∏‰∫ã‰ª∂');
                }
            });

            document.querySelectorAll('.fn-key').forEach(button => {
                button.addEventListener('click', () => {
                    handleFnKeyPress(button.dataset.key);
                });
            });

        }

        // Ë¶ñË®äÈÄ£Êé•ÊåâÈàïÁöÑÊèêÁ§∫ÂáΩÊï∏
        function highlightConnectCapture() {
            if (!connectCaptureButton.classList.contains('highlight-button')) {
                // Â¢ûÂä†ÈñÉÁàçÊïàÊûú
                connectCaptureButton.classList.add('highlight-button');
                
                // Âª∫Á´ãÊèêÁ§∫Ê°Ü
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.textContent = 'Ë´ãÂÖàÈÄ£Êé•Ë¶ñË®äÁï´Èù¢ÔºåÂÜçÈÄ£Êé•ÊéßÂà∂Âô®„ÄÇ';
                
                // Ë®àÁÆó‰ΩçÁΩÆ
                const buttonRect = connectCaptureButton.getBoundingClientRect();
                tooltip.style.left = `${buttonRect.left + (buttonRect.width / 2)}px`;
                tooltip.style.top = `${buttonRect.bottom + 10}px`;
                tooltip.style.transform = 'translateX(-50%)';
                
                // Âä†ÂÖ•Âà∞ body ‰∏≠
                document.body.appendChild(tooltip);
                
                // Ë®≠ÂÆöÊôÇÂô®ÁßªÈô§ÊïàÊûú
                setTimeout(() => {
                    connectCaptureButton.classList.remove('highlight-button');
                    document.body.removeChild(tooltip);
                }, 3000);
            }
        }


        function removeEventListeners() {
            if (keyEventListener) {
                overlay.removeEventListener('keydown', keyEventListener);
                overlay.removeEventListener('keyup', keyEventListener);
                keyEventListener = null;
            }
    
            if (mouseMoveListener) {
                overlay.removeEventListener('mousemove', mouseMoveListener);
                mouseMoveListener = null;
            }
    
            if (mouseClickListener) {
                overlay.removeEventListener('mousedown', mouseClickListener);
                overlay.removeEventListener('mouseup', mouseClickListener);
                mouseClickListener = null;
            }
    
            overlay.removeEventListener('wheel', handleMouseWheel);

            ctrlAltDelButton.removeEventListener('click', sendCtrlAltDel);
            winButton.removeEventListener('click', toggleWinKey);
            ctrlButton.removeEventListener('click', toggleCtrlKey);
            altButton.removeEventListener('click', toggleAltKey);
            fnButton.removeEventListener('click', toggleFnKeys);
            releaseAllModifiersButton.removeEventListener('click', releaseAllModifiers);
       
            overlay.removeEventListener('mouseleave', handleMouseLeave);
    
            document.querySelectorAll('.fn-key').forEach(button => {
                button.removeEventListener('click', () => {
                    handleFnKeyPress(button.dataset.key);
                });
            });
        }

        async function sendTextByChar() {
            if (!isPasting || !port) {
                resetPasteStatus();
                return;
            }

            if (isPausePasting) {
                setTimeout(sendTextByChar, 100);
                return;
            }

            if (currentPasteIndex >= textToSend.length) {
                resetPasteStatus();
                pasteDialog.style.display = 'none';
                return;
            }

            try {
                const char = textToSend[currentPasteIndex];
                const DELAY = 10; // Â¢ûÂä†Âª∂ÈÅ≤ÊôÇÈñìÂà∞ 50ms

                async function sendKeyStrokes(keystrokes) {
                    for (const stroke of keystrokes) {
                        try {
                            await safeWrite(stroke + '\n');
                            // ÊØèÂÄãÊåâÈçµÊìç‰Ωú‰πãÈñìÂª∂ÈÅ≤‰∏Ä‰∏ã
                            await new Promise(resolve => setTimeout(resolve, DELAY));
                        } catch (error) {
                            console.error('ÂÇ≥ÈÄÅÊåâÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                            throw error;
                        }
                    }
                }

                function getKeyStrokes(char) {
                    // Âà§Êñ∑ÊòØÂê¶ÈúÄË¶Å Shift
                    let needShift = char >= 'A' && char <= 'Z' || "~!@#$%^&*()_+{}|:\"<>?".includes(char);
                    
                    let keyCode;
                    switch (char) {
                        // ÁâπÊÆäÁ¨¶ËôüÁöÑÂ∞çÊáâ
                        case '!': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit1', 'B:KEY_UP Digit1', 'B:MOD_UP Shift'] : null;
                        case '@': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit2', 'B:KEY_UP Digit2', 'B:MOD_UP Shift'] : null;
                        case '#': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit3', 'B:KEY_UP Digit3', 'B:MOD_UP Shift'] : null;
                        case '$': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit4', 'B:KEY_UP Digit4', 'B:MOD_UP Shift'] : null;
                        case '%': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit5', 'B:KEY_UP Digit5', 'B:MOD_UP Shift'] : null;
                        case '^': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit6', 'B:KEY_UP Digit6', 'B:MOD_UP Shift'] : null;
                        case '&': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit7', 'B:KEY_UP Digit7', 'B:MOD_UP Shift'] : null;
                        case '*': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit8', 'B:KEY_UP Digit8', 'B:MOD_UP Shift'] : null;
                        case '(': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit9', 'B:KEY_UP Digit9', 'B:MOD_UP Shift'] : null;
                        case ')': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit0', 'B:KEY_UP Digit0', 'B:MOD_UP Shift'] : null;
                        
                        // Ê®ôÈªûÁ¨¶Ëôü
                        case '_': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Minus', 'B:KEY_UP Minus', 'B:MOD_UP Shift'];
                        case '+': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Equal', 'B:KEY_UP Equal', 'B:MOD_UP Shift'];
                        case '{': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN BracketLeft', 'B:KEY_UP BracketLeft', 'B:MOD_UP Shift'];
                        case '}': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN BracketRight', 'B:KEY_UP BracketRight', 'B:MOD_UP Shift'];
                        case '|': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Backslash', 'B:KEY_UP Backslash', 'B:MOD_UP Shift'];
                        case ':': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Semicolon', 'B:KEY_UP Semicolon', 'B:MOD_UP Shift'];
                        case '"': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Quote', 'B:KEY_UP Quote', 'B:MOD_UP Shift'];
                        case '<': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Comma', 'B:KEY_UP Comma', 'B:MOD_UP Shift'];
                        case '>': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Period', 'B:KEY_UP Period', 'B:MOD_UP Shift'];
                        case '?': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Slash', 'B:KEY_UP Slash', 'B:MOD_UP Shift'];
                        case '~': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Backquote', 'B:KEY_UP Backquote', 'B:MOD_UP Shift'];

                        // Âü∫Êú¨Á¨¶Ëôü
                        case '-': return ['B:KEY_DOWN Minus', 'B:KEY_UP Minus'];
                        case '=': return ['B:KEY_DOWN Equal', 'B:KEY_UP Equal'];
                        case '[': return ['B:KEY_DOWN BracketLeft', 'B:KEY_UP BracketLeft'];
                        case ']': return ['B:KEY_DOWN BracketRight', 'B:KEY_UP BracketRight'];
                        case '\\': return ['B:KEY_DOWN Backslash', 'B:KEY_UP Backslash'];
                        case ';': return ['B:KEY_DOWN Semicolon', 'B:KEY_UP Semicolon'];
                        case "'": return ['B:KEY_DOWN Quote', 'B:KEY_UP Quote'];
                        case ',': return ['B:KEY_DOWN Comma', 'B:KEY_UP Comma'];
                        case '.': return ['B:KEY_DOWN Period', 'B:KEY_UP Period'];
                        case '/': return ['B:KEY_DOWN Slash', 'B:KEY_UP Slash'];
                        case '`': return ['B:KEY_DOWN Backquote', 'B:KEY_UP Backquote'];
                        case ' ': return ['B:KEY_DOWN Space', 'B:KEY_UP Space'];

                        // ÊèõË°åËôïÁêÜ
                        case '\n':
                        case '\r':
                            return ['B:KEY_DOWN Enter', 'B:KEY_UP Enter'];

                        default:
                            if (char >= 'A' && char <= 'Z') {
                                return [
                                    'B:MOD_DOWN Shift',
                                    `B:KEY_DOWN Key${char}`,
                                    `B:KEY_UP Key${char}`,
                                    'B:MOD_UP Shift'
                                ];
                            } else if (char >= 'a' && char <= 'z') {
                                return [
                                    `B:KEY_DOWN Key${char.toUpperCase()}`,
                                    `B:KEY_UP Key${char.toUpperCase()}`
                                ];
                            } else if (char >= '0' && char <= '9') {
                                return [
                                    `B:KEY_DOWN Digit${char}`,
                                    `B:KEY_UP Digit${char}`
                                ];
                            }
                            return null;
                    }
                }

                const keyStrokes = getKeyStrokes(char);
                if (keyStrokes) {
                    await sendKeyStrokes(keyStrokes);
                }

                currentPasteIndex++;
                pasteStatus.textContent = currentPasteIndex;
                pastePercent.textContent = Math.round((currentPasteIndex / textToSend.length) * 100);

                setTimeout(sendTextByChar, DELAY);

            } catch (error) {
                console.error('ÂÇ≥ÈÄÅÊñáÂ≠óÊôÇÁôºÁîüÈåØË™§:', error);
                resetPasteStatus();
                alert('ÂÇ≥ÈÄÅÊñáÂ≠óÊôÇÁôºÁîüÈåØË™§ÔºåË´ãÈáçË©¶');
            }
        }

   
        async function handleMouseWheel(event) {
            if (port) {
                const now = Date.now();
                if (now - lastWheelTime < WHEEL_DELAY) {
                    return;
                }
                lastWheelTime = now;

                event.preventDefault();
                const scrollAmount = -Math.sign(event.deltaY);
                
                try {
                    const data = `B:MOUSE_SCROLL ${scrollAmount}\n`;
                    await safeWrite(data);
                } catch (error) {
                    console.error('ÂÇ≥ÈÄÅÊªëÈº†ÊªæËº™‰∫ã‰ª∂ÊôÇÁôºÁîüÈåØË™§:', error);
                }
            }
        }

        async function sendKeyToArduino(event) {
            if (port) {
                overlay.focus();

                const type = event.type === 'keydown' ? 'KEY_DOWN' : 'KEY_UP';
                const key = event.code;

                if (type === 'KEY_DOWN') {
                    pressedKeys.add(key);
                } else {
                    pressedKeys.delete(key);
                }

                if (modifierKeys[key]) {
                    const modifier = modifierKeys[key];
                    const modType = event.type === 'keydown' ? 'MOD_DOWN' : 'MOD_UP';
                    const data = `B:${modType} ${modifier}\n`;

                    try {
                        await safeWrite(data);
                        console.log(`Â∑≤ÂÇ≥ÈÄÅ‰øÆÈ£æÈçµÔºö${data.trim()}`);
                    } catch (error) {
                        console.error('ÂÇ≥ÈÄÅ‰øÆÈ£æÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                } else {
                    const data = `B:${type} ${key}\n`;

                    try {
                        await safeWrite(data);
                        console.log(`Â∑≤ÂÇ≥ÈÄÅÊåâÈçµÔºö${data.trim()}`);
                    } catch (error) {
                        console.error('ÂÇ≥ÈÄÅÊåâÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }
            }
        }
    
        async function handleVisibilityChange() {
            if (document.hidden || document.visibilityState === 'hidden') {
                if (port) {
                    try {
                        // ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§Âà∞ Arduino
                        await safeWrite('B:RELEASE_ALL\n');
                        console.log('Â∑≤ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§');
                        await releaseAllKeys();
                    } catch (error) {
                        console.error('ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§ÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }
            }
        }
    
        async function sendMouseMovementToArduino(event) {
            if (port) {
                const rect = video.getBoundingClientRect();
                const videoAspectRatio = video.videoWidth / video.videoHeight;
                const elementAspectRatio = rect.width / rect.height;

                let videoDisplayWidth, videoDisplayHeight;
                let offsetX, offsetY;

                if (videoAspectRatio > elementAspectRatio) {
                    videoDisplayWidth = rect.width;
                    videoDisplayHeight = rect.width / videoAspectRatio;
                    offsetX = rect.left;
                    offsetY = rect.top + (rect.height - videoDisplayHeight) / 2;
                } else {
                    videoDisplayWidth = rect.height * videoAspectRatio;
                    videoDisplayHeight = rect.height;
                    offsetX = rect.left + (rect.width - videoDisplayWidth) / 2;
                    offsetY = rect.top;
                }

                const mouseX = (event.clientX - offsetX);
                const mouseY = (event.clientY - offsetY);

                if (mouseX >= 0 && mouseX <= videoDisplayWidth && mouseY >= 0 && mouseY <= videoDisplayHeight) {
                    const relativeX = mouseX / videoDisplayWidth;
                    const relativeY = mouseY / videoDisplayHeight;

                    const absoluteX = Math.round((relativeX * 2 - 1) * 32767);
                    const absoluteY = Math.round((relativeY * 2 - 1) * 32767);

                    const currentTime = Date.now();

                    if (currentTime - lastConsoleLogTime >= 1000) {
                        console.log(`Ë®àÁÆóÂæåÁöÑÁµïÂ∞çÂ∫ßÊ®ôÔºöX=${absoluteX}, Y=${absoluteY}`);
                        lastConsoleLogTime = currentTime;
                    }

                    if (lastMouseX !== absoluteX || lastMouseY !== absoluteY) {
                        const data = `B:MOUSE_MOVE_TO ${absoluteX} ${absoluteY}\n`;

                        try {
                            await safeWrite(data);
                            lastMouseX = absoluteX;
                            lastMouseY = absoluteY;
                        } catch (error) {
                            console.error('ÂÇ≥ÈÄÅÊªëÈº†ÁµïÂ∞ç‰ΩçÁΩÆÊôÇÁôºÁîüÈåØË™§:', error);
                        }
                    }
                }
            }
        }
    
        async function sendMouseClickToArduino(event) {
            if (port) {
                event.preventDefault();
                const type = event.type === 'mousedown' ? 'MOUSE_DOWN' : 'MOUSE_UP';
                let button = '';
                if (event.button === 0) button = 'LEFT';
                else if (event.button === 1) button = 'MIDDLE';
                else if (event.button === 2) button = 'RIGHT';

                const data = `B:${type} ${button}\n`;

                try {
                    await safeWrite(data);
                    console.log(`Â∑≤ÂÇ≥ÈÄÅÊªëÈº†ÈªûÊìäÔºö${data.trim()}`);
                } catch (error) {
                    console.error('ÂÇ≥ÈÄÅÊªëÈº†ÈªûÊìäÊôÇÁôºÁîüÈåØË™§:', error);
                }
            }
        }
    
        function handleMouseLeave() {
            lastMouseX = null;
            lastMouseY = null;
        }
    
        async function sendCtrlAltDel() {
            if (port) {
                try {
                    await safeWrite('B:KEY_DOWN Control\n');
                    await safeWrite('B:KEY_DOWN Alt\n');
                    await safeWrite('B:KEY_DOWN Delete\n');
                    await new Promise(resolve => setTimeout(resolve, 100));
                    await safeWrite('B:KEY_UP Delete\n');
                    await safeWrite('B:KEY_UP Alt\n');
                    await safeWrite('B:KEY_UP Control\n');
                    console.log('Â∑≤ÂÇ≥ÈÄÅ Ctrl+Alt+Delete');
                } catch (error) {
                    console.error('ÂÇ≥ÈÄÅ Ctrl+Alt+Delete ÊôÇÁôºÁîüÈåØË™§:', error);
                }
            }
        }
    
        async function toggleWinKey() {
            if (port) {
                if (pressedModifiers.has('Meta')) {
                    try {
                        await safeWrite('B:KEY_UP Meta\n');
                        console.log('Â∑≤ÈáãÊîæ Win Èçµ');
                        pressedModifiers.delete('Meta');
                        winButton.classList.remove('active');
                    } catch (error) {
                        console.error('ÈáãÊîæ Win ÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                } else {
                    try {
                        await safeWrite('B:KEY_DOWN Meta\n');
                        console.log('Â∑≤Êåâ‰∏ã Win Èçµ');
                        pressedModifiers.add('Meta');
                        winButton.classList.add('active');
                    } catch (error) {
                        console.error('Êåâ‰∏ã Win ÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }
            }
        }

        async function toggleCtrlKey() {
            if (port) {
                if (pressedModifiers.has('Control')) {
                    try {
                        await safeWrite('B:KEY_UP Control\n');
                        console.log('Â∑≤ÈáãÊîæ Ctrl Èçµ');
                        pressedModifiers.delete('Control');
                        ctrlButton.classList.remove('active');
                    } catch (error) {
                        console.error('ÈáãÊîæ Ctrl ÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                } else {
                    try {
                        await safeWrite('B:KEY_DOWN Control\n');
                        console.log('Â∑≤Êåâ‰∏ã Ctrl Èçµ');
                        pressedModifiers.add('Control');
                        ctrlButton.classList.add('active');
                    } catch (error) {
                        console.error('Êåâ‰∏ã Ctrl ÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }
            }
        }

        async function toggleAltKey() {
            if (port) {
                if (pressedModifiers.has('Alt')) {
                    try {
                        await safeWrite('B:KEY_UP Alt\n');
                        console.log('Â∑≤ÈáãÊîæ Alt Èçµ');
                        pressedModifiers.delete('Alt');
                        altButton.classList.remove('active');
                    } catch (error) {
                        console.error('ÈáãÊîæ Alt ÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                } else {
                    try {
                        await safeWrite('B:KEY_DOWN Alt\n');
                        console.log('Â∑≤Êåâ‰∏ã Alt Èçµ');
                        pressedModifiers.add('Alt');
                        altButton.classList.add('active');
                    } catch (error) {
                        console.error('Êåâ‰∏ã Alt ÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }
            }
        }

        function toggleFnKeys(event) {
            if (!isFnPopupVisible) {
                const buttonRect = fnButton.getBoundingClientRect();
                fnKeysPopup.style.display = 'grid';
                fnKeysPopup.style.top = `${buttonRect.bottom + 5}px`;
                fnKeysPopup.style.left = `${buttonRect.left}px`;
                isFnPopupVisible = true;
                fnButton.classList.add('active');
            } else {
                closeFnPopup();
            }
        }

        function resetPasteStatus() {
            isPasting = false;
            isPausePasting = false;
            currentPasteIndex = 0;
            startPasteButton.disabled = false;
            pasteArea.disabled = false;
            pausePasteButton.textContent = 'Êö´ÂÅú';
            //pasteArea.value = '';  // Ê∏ÖÁ©∫ÊñáÂ≠óÂçÄÂüü
        }

        async function handleFnKeyPress(key) {
            if (port) {
                try {
                    await safeWrite(`B:KEY_DOWN ${key}\n`);
                    await new Promise(resolve => setTimeout(resolve, 50));
                    await safeWrite(`B:KEY_UP ${key}\n`);
                    console.log(`Â∑≤ÂÇ≥ÈÄÅÂäüËÉΩÈçµÔºö${key}`);
                } catch (error) {
                    console.error(`ÂÇ≥ÈÄÅÂäüËÉΩÈçµ ${key} ÊôÇÁôºÁîüÈåØË™§:`, error);
                }
            }
            closeFnPopup();
        }

        function closeFnPopup() {
            fnKeysPopup.style.display = 'none';
            isFnPopupVisible = false;
            fnButton.classList.remove('active');
        }

        // Ë¶ñÁ™óÊãñÊõ≥ÂäüËÉΩ
        function makeWindowDraggable(windowElement, headerElement) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            headerElement.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e.preventDefault();
                
                const windowRect = windowElement.getBoundingClientRect();
                const containerRect = document.getElementById('videoContainer').getBoundingClientRect();
                const headerHeight = document.getElementById('terminalHeader').offsetHeight;

                // Ë®àÁÆóÊñ∞‰ΩçÁΩÆ
                const newLeft = windowElement.offsetLeft + e.clientX - pos3;
                const newTop = windowElement.offsetTop + e.clientY - pos4;

                // Ë®≠ÂÆöÈÇäÁïåÈôêÂà∂
                const maxLeft = containerRect.width - windowRect.width;

                // ‰øÆÊ≠£‰∏ãÈÇäÁïåË®àÁÆóÔºåÊ∏õÂéªÊ®ôÈ°åÊ¨ÑÈ´òÂ∫¶
                const maxTop = containerRect.height - windowRect.height + headerHeight;

                // ÈôêÂà∂Âú®Ë¶ñÁ™óÂÆπÂô®ÂÖß
                windowElement.style.left = `${Math.min(Math.max(0, newLeft), maxLeft)}px`;
                windowElement.style.top = `${Math.min(Math.max(0, newTop), maxTop)}px`;

                pos3 = e.clientX;
                pos4 = e.clientY;
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        async function releaseAllModifiers() {
            if (port) {
                try {
                    await safeWrite('B:RELEASE_ALL\n');
                    console.log('Â∑≤ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§');
                    pressedModifiers.clear();
                    winButton.classList.remove('active');
                    ctrlButton.classList.remove('active');
                    altButton.classList.remove('active');
                } catch (error) {
                    console.error('ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§ÊôÇÁôºÁîüÈåØË™§:', error);
                }
            }
        }

        async function releaseAllKeys() {
            if (port) {
                try {
                    await safeWrite('B:RELEASE_ALL\n');
                    console.log('Â∑≤ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§');

                    pressedKeys.clear();
                    pressedModifiers.clear();
                    winButton.classList.remove('active');
                    ctrlButton.classList.remove('active');
                    altButton.classList.remove('active');
                } catch (error) {
                    console.error('ÈáãÊîæÊâÄÊúâÊåâÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                }
            }
        }

        async function resetButtonStates() {
            if (pressedModifiers.size > 0) {
                if (writer) {
                    await releaseAllModifiers();
                } else {
                    pressedModifiers.clear();
                    winButton.classList.remove('active');
                    ctrlButton.classList.remove('active');
                    altButton.classList.remove('active');
                }
            }
        }

       
        function updateTerminalButtonStates(isConnected) {
            const terminalConnect = document.getElementById('terminalConnect');
            const terminalClear = document.getElementById('terminalClear');
            const terminalDownload = document.getElementById('terminalDownload');
            const terminalBaudRate = document.getElementById('terminalBaudRate');
            const lineEndingMode = document.getElementById('lineEndingMode');

            if (terminalConnect) terminalConnect.disabled = isConnected;
            if (terminalClear) terminalClear.disabled = !isConnected;
            if (terminalDownload) terminalDownload.disabled = !isConnected;
            //if (terminalBaudRate) terminalBaudRate.disabled = isConnected;
            //if (lineEndingMode) lineEndingMode.disabled = isConnected;
        }

        function updateMainControllerButtons(isConnected) {
            const connectController = document.getElementById('connectController');
            const disconnectController = document.getElementById('disconnectController');

            if (connectController) connectController.disabled = isConnected;
            if (disconnectController) disconnectController.disabled = !isConnected;
        }

        function setupTerminalEventListeners() {
            // Áõ£ËÅΩÈÄüÁéáËÆäÊõ¥
            const baudRateSelect = document.getElementById('terminalBaudRate');
            if (baudRateSelect) {
                baudRateSelect.addEventListener('change', async (e) => {
                    if (port) {
                        const baudRate = parseInt(e.target.value);
                        try {
                            await safeWrite(`R:BAUD=${baudRate}\n`);
                            if (window.term) {
                                term.writeln(`RS232 baud rate changed to ${baudRate}`);
                            }
                        } catch (error) {
                            console.error('ËÆäÊõ¥ÈÄüÁéáÊôÇÁôºÁîüÈåØË™§:', error);
                            if (window.term) {
                                term.writeln(`Failed to change baud rate: ${error.message}`);
                            }
                        }
                    }
                });
            }
            
            const terminalClear = document.getElementById('terminalClear');
            if (terminalClear) {
                terminalClear.addEventListener('click', () => {
                    if (window.term) {
                        window.term.clear();
                    }
                });
            }
        }
    
      
        // ÈáãÊîæ Writer ÁöÑËºîÂä©ÂáΩÊï∏
        async function releaseWriter() {
            if (writer) {
                try {
                    await writer.close();
                    writer.releaseLock();
                } catch (error) {
                    console.error('ÈáãÊîæ writer ÊôÇÁôºÁîüÈåØË™§:', error);
                }
                writer = null;
            }
        }

        async function safeWrite(data) {
            if (!port) return;
            
            let tempWriter = null;
            try {
                if (writer) {
                    writer.releaseLock();
                    writer = null;
                }
                tempWriter = port.writable.getWriter();
                await tempWriter.write(new TextEncoder().encode(data));
            } catch (error) {
                console.error('ÂØ´ÂÖ•Ë≥áÊñôÊôÇÁôºÁîüÈåØË™§:', error);
            } finally {
                if (tempWriter) {
                    try {
                        tempWriter.releaseLock();
                    } catch (error) {
                        console.error('ÈáãÊîæ writer ÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }
            }
        }

      
        function initializeTerminal() {
            // Âª∫Á´ãÁµÇÁ´ØÊ©üÂÄãÈ´î
            window.term = new Terminal({
                cursorBlink: true,
                cursorStyle: 'block',
                fontSize: 14,
                fontFamily: 'monospace',
                theme: {
                    background: '#000',
                    foreground: '#00ff00'
                }
            });

            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(document.getElementById('terminal-container'));
            fitAddon.fit();


            const lineEndingSelect = document.getElementById('lineEndingMode');
            // ËºâÂÖ•ÂÑ≤Â≠òÁöÑÊèõË°åÊ®°Âºè
            const savedLineEnding = localStorage.getItem('terminalLineEnding') || 'CRLF';
            let currentLineEnding = LINE_ENDING_MODES[savedLineEnding] || '\r\n';
            lineEndingSelect.value = savedLineEnding;
            
            // Âç≥ÊôÇÊèõË°åÊ®°ÂºèÂàáÊèõËôïÁêÜ
            lineEndingSelect.addEventListener('change', (e) => {
                const newMode = e.target.value;
                currentLineEnding = LINE_ENDING_MODES[newMode];
                localStorage.setItem('terminalLineEnding', newMode);
                console.log(`ÊèõË°åÊ®°ÂºèÂ∑≤ÂàáÊèõÁÇ∫: ${newMode}`);
            });

           

           // ËôïÁêÜÁµÇÁ´ØÊ©üËº∏ÂÖ•Ôºå‰ΩøÁî®Áï∂ÂâçÈÅ∏ÊìáÁöÑÊèõË°åÊ®°Âºè
            term.onData(async data => {
                if (!port) return;
                
                try {
                    if (data === '\r') {
                        // ‰ΩøÁî®Áï∂ÂâçÈÅ∏ÊìáÁöÑÊèõË°åÊ®°Âºè
                        await safeWrite(`R:${currentLineEnding}`);
                    } else {
                        await safeWrite('R:' + data);
                    }
                } catch (error) {
                    console.error('ÂØ´ÂÖ•Â∫èÂàóÂü†ÊôÇÁôºÁîüÈåØË™§:', error);
                    term.writeln('\r\nÈåØË™§ÔºöÂØ´ÂÖ•Â∫èÂàóÂü†Â§±Êïó');
                }
            });

            // ÂàùÂßãÈÄ£Á∑öÁãÄÊÖãÊ™¢Êü•
            if (port) {
                updateTerminalButtonStates(true);
                // Â¶ÇÊûúÂ∑≤Á∂ìÊúâÈÄ£Êé•ÔºåË®≠ÂÆö RS232 ÁöÑÈÄüÁéá‰∏¶Ë®≠ÁΩÆÂÖ±‰∫´ reader
                const baudRate = parseInt(document.getElementById('terminalBaudRate').value);
                safeWrite(`R:BAUD=${baudRate}\n`);
                setupSharedReader();
                term.writeln(`Terminal initialized (RS232 Rate: ${baudRate})`);
            } else {
                term.writeln('Terminal initialized (Not connected)');
            }

            document.getElementById('terminalConnect').addEventListener('click', async () => {
                if (!port) {
                    try {
                        const filters = [{
                            usbVendorId: 0x2341,
                            usbProductId: 0x8036
                        }];
                        
                        const baudRate = parseInt(document.getElementById('terminalBaudRate').value);
                        port = await navigator.serial.requestPort({ filters });
                        await port.open({ baudRate: 115200 });
                        
                        await safeWrite(`R:BAUD=${baudRate}\n`);
                        setupSharedReader();
                        term.writeln(`Connected to serial port (RS232 Rate: ${baudRate})`);
                        updateTerminalButtonStates(true);
                        addEventListeners();
                        enableMainControls();

                    } catch (error) {
                        console.error('Terminal connection error:', error);
                        term.writeln(`Error: ${error.message}`);
                        
                        if (error.name === 'NetworkError') {
                            alert('ÁÑ°Ê≥ïÈñãÂïüÂ∫èÂàóÂü†ÔºåÂèØËÉΩË¢´ÂÖ∂‰ªñÁ®ãÂºè‰ΩîÁî®‰∏≠„ÄÇË´ãÈóúÈñâÂÖ∂‰ªñ‰ΩøÁî®Ê≠§Ë£ùÁΩÆÁöÑÁ®ãÂºèÂæåÂÜçË©¶„ÄÇ');
                        } else {
                            alert('ÈÄ£Êé•ÊéßÂà∂Âô®ÊôÇÁôºÁîüÈåØË™§: ' + error.message);
                        }
                    }
                } else {
                    const baudRate = parseInt(document.getElementById('terminalBaudRate').value);
                    await safeWrite(`R:BAUD=${baudRate}\n`);
                    setupSharedReader();
                    term.writeln(`RS232 baud rate set to ${baudRate}`);
                }
            });

            // ‰∏ãËºâË®òÈåÑÊåâÈàï‰∫ã‰ª∂
            document.getElementById('terminalDownload').addEventListener('click', () => {
                if (window.term) {
                    const content = getAllTerminalContent();
                    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `terminal_log_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            });


            // Ë®≠ÁΩÆÂÖ∂‰ªñ‰∫ã‰ª∂Áõ£ËÅΩÂô®
            setupTerminalEventListeners();
          

            // Ë¶ñÁ™óÂ§ßÂ∞èÊîπËÆäÊôÇË™øÊï¥ÁµÇÁ´ØÊ©üÂ§ßÂ∞è
            const resizeObserver = new ResizeObserver(() => {
                fitAddon.fit();
                window.term.refresh(0, window.term.rows - 1);
            });
            resizeObserver.observe(document.getElementById('terminal-container'));
        }



        // Serial Ë≥áÊñôËÆÄÂèñ
        async function readLoop() {
            while (true) {
                try {
                    const { value, done } = await reader.read();
                    if (done) break;
                    term.write(new TextDecoder().decode(value));
                } catch (err) {
                    console.error('ËÆÄÂèñË≥áÊñôÊôÇÁôºÁîüÈåØË™§:', err);
                    break;
                }
            }
        }


        function enableMainControls() {
            connectControllerButton.disabled = true;
            disconnectControllerButton.disabled = false;
            ctrlAltDelButton.disabled = false;
            winButton.disabled = false;
            ctrlButton.disabled = false;
            altButton.disabled = false;
            fnButton.disabled = false;
            releaseAllModifiersButton.disabled = false;
            pasteTextButton.disabled = false;
        }

        
        function updateTerminalButtons() {
            if (document.getElementById('terminalConnect')) {
                document.getElementById('terminalConnect').disabled = false;
                document.getElementById('terminalResend').disabled = true;
                document.getElementById('terminalClear').disabled = true;
                document.getElementById('terminalBaudRate').disabled = false;
            }
        }


        function getAllTerminalContent() {
            const buffer = term.buffer.active;
            let content = '';
            for (let i = 0; i < buffer.length; i++) {
                const line = buffer.getLine(i);
                if (line) {
                    content += line.translateToString() + '\n';
                }
            }
            return content;
        }

        function setupSharedReader() {
            if (!port || !port.readable) return;

            const decoder = new TextDecoder();
            isReading = true; 

            async function readUntilClosed() {
                try {
                    sharedReader = port.readable.getReader();
                    while (isReading) {  
                        const { value, done } = await sharedReader.read();
                        if (done) break;3
                        if (window.term) {
                            window.term.write(decoder.decode(value));
                        }
                    }
                } catch (error) {
                    if (isReading) { 
                        console.error('ËÆÄÂèñÈåØË™§:', error);
                    }
                } finally {
                    if (sharedReader) {
                        try {
                            sharedReader.releaseLock();
                        } catch (error) {
                            console.error('ÈáãÊîæ reader ÊôÇÁôºÁîüÈåØË™§:', error);
                        }
                        sharedReader = null;
                    }
                }
            }

            readUntilClosed().catch(error => {
                if (isReading) {
                    console.error('Reader loop error:', error);
                }
            });
        }


        connectControllerButton.addEventListener('click', connectController);
        disconnectControllerButton.addEventListener('click', disconnectController);

        // Ë¶ñË®ä‰æÜÊ∫êÂàáÊèõÁöÑÁõ£ËÅΩÂô®
        videoSourceSelect.addEventListener('change', async () => {
            if (videoStream) {
                const selectedDeviceId = videoSourceSelect.value;
                const [width, height] = resolutionSelect.value.split('x').map(Number);

                try {
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: selectedDeviceId },
                            width: { exact: width },
                            height: { exact: height }
                        }
                    });

                    // ÂÅúÊ≠¢ËàäÁöÑË¶ñË®ä‰∏≤ÊµÅ
                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = newStream;
                    video.srcObject = videoStream;

                    // ÂÑ≤Â≠òÈÅ∏ÊìáÁöÑË¶ñË®ä‰æÜÊ∫ê
                    localStorage.setItem('videoSourceId', selectedDeviceId);
                    
                } catch (error) {
                    console.error('ÂàáÊèõË¶ñË®ä‰æÜÊ∫êÂ§±Êïó:', error);
                    alert('ÂàáÊèõË¶ñË®ä‰æÜÊ∫êÂ§±ÊïóÔºåË´ãÈáçË©¶');
                }
            }
        });

        connectCaptureButton.addEventListener('click', startVideoStream);
        disconnectCaptureButton.addEventListener('click', stopVideoStream);

        // Âú®ÈÅ∏ÂèñËß£ÊûêÂ∫¶ÁöÑ‰∏ãÊãâÈÅ∏ÂñÆÂä†ÂÖ•‰∫ã‰ª∂Áõ£ËÅΩ
        resolutionSelect.addEventListener('change', async () => {
            if (videoStream) {
                const [width, height] = resolutionSelect.value.split('x').map(Number);
                const selectedDeviceId = videoSourceSelect.value;

                try {
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: selectedDeviceId },
                            width: { exact: width },
                            height: { exact: height }
                        }
                    });

                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = newStream;
                    video.srcObject = videoStream;
                    
                    localStorage.setItem('resolution', resolutionSelect.value);
                } catch (error) {
                    console.error('ÂàáÊèõËß£ÊûêÂ∫¶Â§±Êïó:', error);
                    alert('ÂàáÊèõËß£ÊûêÂ∫¶Â§±ÊïóÔºåË´ãÈáçË©¶');
                }
            }
        });

        overlay.addEventListener('click', () => {
            overlay.focus();
        });

        overlay.addEventListener('keydown', (event) => {
            if (event.key === 'Tab') {
                event.preventDefault();
                overlay.focus();
            }
        });

        overlay.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });

        document.addEventListener('click', (event) => {
            if (isFnPopupVisible && 
                !fnButton.contains(event.target) && 
                !fnKeysPopup.contains(event.target)) {
                closeFnPopup();
            }
        });




  

        document.addEventListener('visibilitychange', handleVisibilityChange);
        window.addEventListener('blur', handleVisibilityChange);

        window.addEventListener('blur', closeFnPopup);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                closeFnPopup();
            }
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isPasting) {
                isPasting = false;
                isPausePasting = false;
                alert('ÂàáÊèõÂàÜÈ†ÅÂ∞éËá¥ÊñáÂ≠óÂÇ≥ÈÄÅ‰∏≠Êñ∑');
            }
        });

        window.addEventListener('beforeunload', () => {
            releaseAllKeys();
        });

        window.addEventListener('beforeunload', () => {
            if (isPasting) {
                isPasting = false;
                isPausePasting = false;
            }
        });


        // Âú®È†ÅÈù¢ËºâÂÖ•ÊôÇÈ°ØÁ§∫ÊñáÂ≠ó
        window.addEventListener('load', () => {
            document.getElementById('noVideoText').style.display = 'block';
                    
            // ÁµÇÁ´ØÊ©üÊåâÈàï‰∫ã‰ª∂
            document.getElementById('showTerminal').addEventListener('click', () => {
                    const terminalWindow = document.getElementById('terminalWindow');
                    terminalWindow.style.display = 'block';
                    
                    // ÂàùÂßãÂåñÁµÇÁ´ØÊ©üÔºàÂ¶ÇÊûúÈÇÑÊ≤íÊúâÁöÑË©±Ôºâ
                    if (!window.term) {
                        initializeTerminal();
                    }

                    // Ê™¢Êü•ÁõÆÂâçÈÄ£Êé•ÁãÄÊÖãÔºåÊõ¥Êñ∞ÊåâÈàï
                    if (port) {
                        updateTerminalButtonStates(true);
                        // Á¢∫‰øùÈÄüÁéáÈÅ∏È†ÖÂèØÁî®
                        const terminalBaudRate = document.getElementById('terminalBaudRate');
                        if (terminalBaudRate) {
                            terminalBaudRate.disabled = false;
                        }
                    }
                });

                document.getElementById('minimizeTerminal').addEventListener('click', () => {
                    const terminalWindow = document.getElementById('terminalWindow');
                    const terminalContent = document.getElementById('terminalContent');
                    
                    if (terminalContent.style.display !== 'none') {
                        // ÊúÄÂ∞èÂåñ
                        terminalContent.style.display = 'none';
                        terminalWindow.style.height = '36px';  // Âè™‰øùÁïôÊ®ôÈ°åÊ¨ÑÈ´òÂ∫¶
                        terminalWindow.style.resize = 'none';
                    } else {
                        // ÈÇÑÂéü
                        terminalContent.style.display = 'flex';
                        terminalWindow.style.height = '400px';  // ÈÇÑÂéüÈ†êË®≠È´òÂ∫¶
                        terminalWindow.style.resize = 'both';
                    }
                });

                document.getElementById('closeTerminal').addEventListener('click', () => {
                    document.getElementById('terminalWindow').style.display = 'none';
                });

                // ÂàùÂßãÂåñÊãñÊõ≥ÂäüËÉΩ
                makeWindowDraggable(
                    document.getElementById('terminalWindow'),
                    document.getElementById('terminalHeader')
                );

        });

        window.addEventListener('load', async () => {
            try {
                // ‰∏ªÂãïË´ãÊ±ÇË¶ñË®äÊ¨äÈôê
                await navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        // ÂèñÂæóÊ¨äÈôêÂæåÁ´ãÂç≥ÂÅúÊ≠¢ stream
                        stream.getTracks().forEach(track => track.stop());
                    });
            } catch (error) {
                console.error('Ë´ãÊ±ÇË¶ñË®äÊ¨äÈôêÂ§±Êïó:', error);
            }

            screenshotButton.addEventListener('click', takeScreenshot);
            startRecordButton.addEventListener('click', startRecording);
            stopRecordButton.addEventListener('click', stopRecording);

            await getVideoSources();

            overlay.tabIndex = 0;
            overlay.style.outline = 'none';

            overlay.addEventListener('keydown', checkControllerAndHighlight);
            overlay.addEventListener('mousedown', checkControllerAndHighlight);
            overlay.addEventListener('contextmenu', checkControllerAndHighlight);

            document.getElementById('videoContainer').addEventListener('keydown', (event) => {
                if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'a') {
                    event.preventDefault();
                }
            });

            video.addEventListener('keydown', (event) => {
                if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'a') {
                    event.preventDefault();
                }
            });


            video.addEventListener('loadedmetadata', () => {
                console.log('Ë¶ñË®ä‰∏≠ÁπºË≥áÊñôÂ∑≤ËºâÂÖ•');
            });


            // Áõ£ËÅΩÊåâÈàïÈªûÊìä‰∫ã‰ª∂
            zoomInButton.addEventListener('click', zoomIn);
            zoomOutButton.addEventListener('click', zoomOut);

            // ÂàùÂßãÂåñÊåâÈàïÁãÄÊÖã
            applyZoom();
        });


    </script>


    <div id="terminalWindow" style="display: none;">
        <div id="terminalHeader">
            <div class="header-title">
                <span class="header-icon">üñ•Ô∏è</span>
                <span>Â∫èÂàóÁµÇÁ´ØÊ©ü</span>
            </div>
            <div class="terminal-controls">
                <button id="minimizeTerminal">‚îÄ</button>
                <button id="closeTerminal">√ó</button>
            </div>
        </div>
        <div id="terminalContent">
            <div class="button-group">
                <span class="terminal-label">ÈÄüÁéá</span>
                <select id="terminalBaudRate" title="Â§ßÈÉ®‰ªΩË£ùÁΩÆÈÅ∏Êìá 9600 Âç≥ÂèØÔºåMikroTike„ÄÅJuniper ÈÉ®‰ªΩÂûãËôüÁÇ∫ 115200">
                    <option value="9600">9600</option>
                    <option value="19200">19200</option>
                    <option value="38400">38400</option>
                    <option value="57600">57600</option>
                    <option value="115200">115200</option>
                </select>
                <span class="terminal-label">ÊèõË°å</span>
                <select id="lineEndingMode" title="Â§ßÈÉ®‰ªΩË£ùÁΩÆÈÅ∏Áî® CRLF Âç≥ÂèØÔºåÂè™ÊúâÂ∞ëÈÉ®‰ªΩÈúÄË¶ÅÂñÆÈÅ∏ LF Êàñ CRÔºå‰æãÂ¶Ç Exterme Ëàá Juniper ÈÉ®‰ªΩÂûãËôü">
                    <option value="CRLF">CRLF (\r\n)</option>
                    <option value="CR">CR (\r)</option>
                    <option value="LF">LF (\n)</option>
                </select>
                <div class="separator"></div>
                <button id="terminalConnect">üîå ÈÄ£Êé•ÊéßÂà∂Âô®</button>
                <button id="terminalClear" hidden>üßπ Ê∏ÖÈô§Áï´Èù¢</button>
                <button id="terminalDownload">‚¨áÔ∏è ‰∏ãËºâË®òÈåÑ</button>
            </div>
            <div id="terminal-container"></div>
        </div>
    </div>

</body>
</html>
