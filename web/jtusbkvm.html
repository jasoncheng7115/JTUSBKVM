<!DOCTYPE html>
<!-- 

=========================================================================

JTUSBKVM - Web Console

Version: 1.4.0
Last Update: 2024-11-26

Author  : Jason Cheng
E-mail  : jason@jason.tools
GitHub  : https://github.com/jasoncheng7115
WebSite : https://blog.jason.tools , https://www.jason.tools 

License: GNU Affero General Public License v3.0
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
any later version.

=========================================================================

This software uses the following open source packages:

Xterm.js - https://github.com/xtermjs/xterm.js
License: MIT License
Copyright (c) 2014-2023, The xterm.js authors (https://github.com/xtermjs/xterm.js)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

=========================================================================

-->
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>JTUSBKVM - Jason Tools</title>
    <link rel="icon" type="image/png" sizes="512x512" href="logo-1.png">
    <link rel="stylesheet" href="js/xterm.css" />
    <script src="js/xterm.js"></script>
    <script src="js/xterm-addon-fit.js"></script>
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body, html {
            height: 100%;
            margin: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #header {
            display: flex;
            flex-direction: column;
            background: #f0f0f0;
            padding: 1px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            gap: 1px;
        }

        #titleContainer {
            display: flex;
            align-items: center;
            padding: 5px;
            border-bottom: 1px solid #ddd;
            margin-bottom: 5px;
        }

        #controls, #rightControls {
            display: inline-flex;  
            align-items: center;
            background: #e8e8e8;
            border-radius: 4px;
            padding: 5px;
            gap: 5px;
            flex: 0 0 auto;  
            white-space: nowrap;  /* é˜²æ­¢å…§å®¹æ›è¡Œ */
        }
        #controlsContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            width: 100%;
            background: #f0f0f0;
            padding: 0px;
        }
        #logo {
            height: 32px;
            margin-right: 10px;
        }
        #title {
            font-weight: bold;
            margin-right: 15px;
        }

        #rightControls .button-group {
            display: inline-flex;
            gap: 3px;
            align-items: center;
            flex-shrink: 0;
        }
        #rightControls {          
            display: inline-flex;
            align-items: center;
            background: #e8e8e8;
            border-radius: 4px;
            padding: 5px;
            gap: 5px;
        }
        #videoContainer {
            flex-grow: 1;
            position: relative;
            background: black;
            overflow: hidden;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #videoContainer.zoomed {
            overflow: auto;
            display: block; /* ä¿®æ”¹ç‚º block ä»¥æ”¯æ´æ­£ç¢ºçš„æ²å‹• */
        }
        #showTerminal {
            margin-left: 15px;
            padding: 5px 15px;
            background-color: #2196F3; 
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #showTerminal:before {
            content: "ğŸ–¥ï¸"; 
            font-size: 14px;
        }

        #showTerminal:hover {
            background-color: #1976D2;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transform: translateY(-1px);
        }

        #showTerminal:active {
            background-color: #0D47A1;
            transform: translateY(1px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        #terminalWindow {
            position: absolute;
            width: 600px;
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            min-width: 400px;
            min-height: 36px;
            resize: both;       
            overflow: auto;     
            padding: 0;         
            box-shadow: rgba(0, 0, 0, 0.3) 0px 19px 38px, 
                        rgba(0, 0, 0, 0.22) 0px 15px 12px;
        }

        #terminalHeader {
            padding: 8px;
            background: #333;
            color: #fff; 
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 36px; 
        }


        #zoomControls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
        }

        #zoomControls button {
            padding: 5px 10px;
            font-size: 14px;
            border: none;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #zoomControls button:hover:not(:disabled) {
            background-color: rgba(200, 200, 200, 0.7);
        }

        #zoomControls button:disabled {
            background-color: rgba(150, 150, 150, 0.7);
            cursor: not-allowed;
        }
        video {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            transition: width 0.3s, height 0.3s;
            display: block;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            outline: none;
            cursor: crosshair;
            z-index: 10;  /* ç¢ºä¿è¦†è“‹å±¤åœ¨æœ€ä¸Šå±¤ */
        }
        select, button, input[type="text"] {
            height: 28px;
            padding: 0 8px;
            font-size: 12px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background: #fff;
            cursor: pointer;
        }
        button:hover, input[type="text"]:hover {
            background-color: #b0b0b0;
        }
        @keyframes buttonHighlight {
            0% { background-color: #e0e0e0; }
            50% { background-color: #ff9999; }
            100% { background-color: #e0e0e0; }
        }
        .highlight-button {
            animation: buttonHighlight 1s ease-in-out 3;  /* é–ƒçˆ 3 æ¬¡ */
        }
        .tooltip {
            position: absolute;
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1000;
            animation: fadeInOut 3s ease-in-out;
            white-space: nowrap;
        }

        .tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 0 8px 8px 8px;
            border-style: solid;
            border-color: transparent transparent #333 transparent;
        }

        /* ç¸®æ”¾æŒ‡ç¤ºå™¨çš„æ¨£å¼ */
        .zoom-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1);
            color: white;
            font-size: 48px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 20px 40px;
            border-radius: 10px;
            opacity: 0;
            pointer-events: none; /* ä½¿æŒ‡ç¤ºå™¨ä¸æœƒå½±éŸ¿æ»‘é¼ äº‹ä»¶ */
            transition: opacity 0.5s ease, transform 0.5s ease;
            z-index: 20; /* ç¢ºä¿æŒ‡ç¤ºå™¨åœ¨è¦–è¨Šå’Œè¦†è“‹å±¤ä¹‹ä¸Š */
        }

        /* é¡¯ç¤ºæ™‚çš„æ¨£å¼ */
        .zoom-indicator.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }
        @keyframes fadeInOut {
            0% { opacity: 0; }
            15% { opacity: 1; }
            85% { opacity: 1; }
            100% { opacity: 0; }
        }        

        .zoom-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
        }

        #videoContainer {
            position: relative;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background: black;
        }

        #videoContainer.zoomed {
            overflow: auto;
        }

        #video {
            display: block;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            cursor: crosshair;
            z-index: 10;
        }


        .toggle-button:hover {
            background-color: #909090;
        }
        .toggle-button.active:hover {
            background-color: #555555;
        }
        button:active, .toggle-button:active, input[type="text"]:active {
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-button {
            background-color: #e0e0e0;
        }
        .toggle-button.active {
            background-color: #a0a0a0;
            color: white;
        }
        button:disabled, input[type="text"]:disabled {
            opacity: 0.5;
            border-color: #ccc;
            cursor: not-allowed;
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .button-group {
            display: inline-flex;  /* æ”¹ç‚º inline-flex */
            gap: 3px;
            align-items: center;
            flex-shrink: 0;  /* é˜²æ­¢æŒ‰éˆ•çµ„è¢«å£“ç¸® */
        }
  
        .separator {
            height: 28px;
            margin: 0 5px;
            border-left: 1px solid #ccc;
            flex-shrink: 0;
        }
        select, button {
            height: 28px;
            padding: 0 8px;
            font-size: 12px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .header-label {
            height: 32px;
            line-height: 32px;
            font-size: 14px;
            font-weight: bold; 
            flex-shrink: 0;  /* é˜²æ­¢æ¨™ç±¤è¢«å£“ç¸® */
            white-space: nowrap;
        }
        .button-wrapper {
            display: flex;
            flex: 1;
            gap: 5px;
            flex-wrap: wrap;
            margin-left: auto;  /* å°‡æ•´å€‹æŒ‰éˆ•å€æ¨åˆ°æ¨™ç±¤å³å´ */
        }
        .terminal-label {
            line-height: 28px;
            margin: 0;
            padding: 0 5px;
            font-weight: bold;
            font-size: 12px;
            color: #fff;  /* æ·ºè‰²æ–‡å­—ï¼Œç”¨æ–¼æ·±è‰²èƒŒæ™¯ */
        }
        .terminal-controls button {
            width: 24px;          /* å›ºå®šæŒ‰éˆ•å¯¬åº¦ */
            height: 24px;         /* å›ºå®šæŒ‰éˆ•é«˜åº¦ */
            line-height: 24px;    /* å‚ç›´ç½®ä¸­ */
            padding: 0;
            background: none;
            border: none;
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .terminal-controls {
            display: flex;
            align-items: center;
            gap: 5px;  /* æŒ‰éˆ•é–“è· */
        }
        .terminal-controls button:hover {
            background: #444;
            border-radius: 3px;
        }

        #terminalContent {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: calc(100% - 36px);
            min-height: 250px;
        }
        #terminal-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin: 10px;  
            min-height: 0; 
            scrollbar-width: thin;
            scrollbar-color: #666 #1e1e1e;
        }
        #terminal-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        #terminal-container::-webkit-scrollbar-track {
            background: #1e1e1e;
        }

        #terminal-container::-webkit-scrollbar-thumb {
            background-color: #666;
            border-radius: 4px;
            border: 2px solid #1e1e1e;
        }

        #terminal-container::-webkit-scrollbar-thumb:hover {
            background-color: #888;
        }
        .header-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-icon {
            font-size: 16px;
        }
        .xterm {
            flex: 1;
            height: 100% !important;
        }
        #fnKeysPopup {
            display: none;
            position: absolute;
            background: #f0f0f0;
            border: 1px solid #000;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }
        #fnKeysPopup button {
            padding: 5px 10px;
            margin: 0;
            width: 100%;
        }
        #noVideoText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            display: none;
            z-index: 5;  /* ç¢ºä¿æ–‡å­—åœ¨è¦–è¨Šä¹‹ä¸Šï¼Œä½†åœ¨è¦†è“‹å±¤ä¹‹ä¸‹ */
        }
        #recordingTime {
            display: none;
            margin: 0 8px;
            font-family: monospace;
            font-size: 12px;
            line-height: 28px;
            color: #ff0000;
            font-weight: bold;
            min-width: 70px;
        }
        #video:not([src]):not([srcObject]) + #overlay + #noVideoText {
            display: block;
        }
        @media (max-width: 768px) {
            #controls, #rightControls {
                width: 100%;
            }
            
            .button-group {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div id="header">
        <div id="titleContainer">
            <img id="logo" src="logo-1.png" alt="Logo">
            <div id="title">JTUSBKVM v1.4</div>
            <button id="showTerminal" title="é–‹å•Ÿç¶²è·¯è£ç½® Console è¨­å®šçµ‚ç«¯æ©ŸåŠŸèƒ½ï¼Œè¨˜å¾—å°‡ RJ45 ç·šæ¥ä¸Šç›®æ¨™è£ç½®çš„ Console é€£æ¥åŸ ">åºåˆ—çµ‚ç«¯æ©Ÿ</button>
        </div>
        <div id="controlsContainer">
            <div id="controls">
                <span class="header-label">æ§åˆ¶</span>
                <div class="button-wrapper">
                    <div class="button-group">
                        <button id="connectController" title="é€£æ¥æ§åˆ¶å™¨ï¼Œåƒ…æ”¯æ´ Arduino Leonardo æˆ– Arduino Pro Micro">ğŸŸ¢ é€£æ¥</button>
                        <button id="disconnectController" disabled>ğŸ”´ ä¸­æ–·</button>
                    </div>
                    <div class="separator"></div>
                    <div class="button-group">
                        <button id="ctrlAltDelButton" disabled>Ctrl+Alt+Del</button>
                        <button id="fnButton" class="toggle-button" disabled>F1-F12</button>
                        <button id="winButton" class="toggle-button" disabled title="Windows Key / Super Key / Command Key">Win</button>
                        <button id="ctrlButton" class="toggle-button" disabled>Ctrl</button>
                        <button id="altButton" class="toggle-button" disabled>Alt</button>
                        <button id="releaseAllModifiers" class="toggle-button" disabled title="å°‡æ‰€æœ‰ç‹€æ…‹ç‚ºæŒ‰ä¸‹çš„ä¿®é£¾éµé‡‹æ”¾">ğŸ”„ é‡‹æ”¾</button>
                        <button id="pasteText" disabled title="å°‡ä¸€ä¸²æ–‡å­—æŒ‡ä»¤è²¼ä¸Šï¼Œä¸¦åœ¨è¢«æ§ç«¯ä¸»æ©Ÿä¸Šä»¥æ¨¡æ“¬éµç›¤æ–¹å¼è¼¸å…¥">ğŸ“‹ è²¼ä¸Š</button>
                    </div>
                </div>
            </div>
        
            <div id="rightControls">
                <span class="header-label">è¦–è¨Š</span>
                <div class="button-wrapper">
                    <div class="button-group">
                        <select id="videoSource"></select>
                        <select id="resolution" title="è¢å¹•æ¯”ä¾‹ï¼Œè«‹é¸æ“‡ç¬¦åˆè¢«æ§ç«¯çš„æ¯”ä¾‹ï¼Œä»¥é¿å…ç™¼ç”Ÿæ¸¸æ¨™åç§»å•é¡Œ">
                            <option value="1440x960" title="1440x960 / 1280x800">3:2</option>
                            <option value="1440x1080" title="1440x1080 / 1024x768 / 800x600">4:3</option>
                            <option value="1800x1080" title="1800x1080 / 1600x960 / 1280x768">5:3</option>
                            <option value="1280x1024" title="1280x1024">5:4</option>
                            <option value="1920x1080" title="1920x1080 / 1600x900 / 1366x768 / 1280x720" selected>16:9</option>
                            <option value="1680x1050" title="1680x1050 / 1600x1000 / 1440x900 / 1280x800">16:10</option>
                            <option value="1920x800" title="1920x800">21:9</option>
                        </select>
                        <button id="connectCapture" title="é€£æ¥è¦–è¨Šæ“·å–å™¨ï¼Œåƒ…æ”¯æ´ USB HDMI Capture è£ç½®">â–¶ï¸ é€£æ¥</button>
                        <button id="disconnectCapture" disabled>â¹ï¸ ä¸­æ–·</button>
                    </div>
                    <div class="separator"></div>
                    <div class="button-group">   
                        <button id="zoomIn" title="æ”¾å¤§è¦–è¨Šç•«é¢æ¯”ä¾‹ï¼Œæœ€å¤§è‡³ 300%">ğŸ”ï¼‹</button>
                        <button id="zoomOut" disabled title="ç¸®å°è¦–è¨Šç•«é¢æ¯”ä¾‹">ğŸ”ï¼</button>
                        <button id="screenshot" disabled title="å°‡è¦–è¨Šç•«é¢æ“·å–åœ–ç‰‡ä¸¦ä¸‹è¼‰">ğŸ–¼ï¸ æ“·åœ–</button>
                        <button id="startRecord" disabled title="é–‹å§‹å°‡è¦–è¨Šç•«é¢éŒ„å½±">ğŸ”´ éŒ„å½±</button>
                        <button id="stopRecord" disabled title="åœæ­¢è¦–è¨Šç•«é¢éŒ„å½±ï¼Œä¸¦ä¸‹è¼‰å½±ç‰‡æª”">â¬› åœæ­¢</button>
                        <span id="recordingTime" style="display: none;">00:00:00</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="fnKeysPopup">
        <button class="fn-key" data-key="F1">F1</button>
        <button class="fn-key" data-key="F2">F2</button>
        <button class="fn-key" data-key="F3">F3</button>
        <button class="fn-key" data-key="F4">F4</button>
        <button class="fn-key" data-key="F5">F5</button>
        <button class="fn-key" data-key="F6">F6</button>
        <button class="fn-key" data-key="F7">F7</button>
        <button class="fn-key" data-key="F8">F8</button>
        <button class="fn-key" data-key="F9">F9</button>
        <button class="fn-key" data-key="F10">F10</button>
        <button class="fn-key" data-key="F11">F11</button>
        <button class="fn-key" data-key="F12">F12</button>
    </div>

    <div id="pasteDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
    background: white; padding: 20px; border: 1px solid #000; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; 
    min-width: 500px; max-width: 80%;">
        <div style="margin-bottom: 10px; font-weight: bold;">æ–‡å­—å‚³é€å·¥å…·</div>
        <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-left: 4px solid #004085; font-size: 14px;">
            <p style="margin: 0 0 8px 0;">æ­¤å·¥å…·æœƒæ¨¡æ“¬éµç›¤åœ¨ç›®æ¨™é›»è…¦ä¸Šé€å­—è¼¸å…¥æ–‡å­—ã€‚</p>
            <p style="margin: 0 0 8px 0;">æ”¯æ´å…§å®¹ï¼š</p>
            <ul style="margin: 0 0 8px 20px; padding: 0;">
                <li>è‹±æ–‡å­—æ¯ï¼ˆå¤§å°å¯«ï¼‰</li>
                <li>æ•¸å­—</li>
                <li>æ¨™é»ç¬¦è™Ÿ</li>
                <li>ç©ºæ ¼å’Œæ›è¡Œ</li>
            </ul>
            <p style="margin: 0; color: #dc3545;">æ³¨æ„ï¼šä¸æ”¯æ´ä¸­æ–‡ã€æ—¥æ–‡ã€éŸ“æ–‡ç­‰éè‹±æ–‡å­—å…ƒ</p>
        </div>
        <div style="margin-bottom: 10px;">è«‹è²¼ä¸Šè¦å‚³é€çš„æ–‡å­—ï¼š</div>
        <textarea id="pasteArea" rows="10" cols="50" style="width: 100%; margin-bottom: 10px; padding: 8px;"></textarea>
        <div id="pasteProgress" style="display: none; margin-bottom: 10px; padding: 8px; background: #e9ecef;">
            é€²åº¦ï¼š<span id="pasteStatus">0</span>/<span id="pasteTotal">0</span> 
            (<span id="pastePercent">0</span>%)
        </div>
        <div style="display: flex; gap: 10px;">
            <button id="startPaste" style="padding: 5px 15px;">é–‹å§‹å‚³é€</button>
            <button id="pausePaste" style="padding: 5px 15px;">æš«åœ</button>
            <button id="cancelPaste" style="padding: 5px 15px;">å–æ¶ˆ</button>
        </div>
    </div>

    <div id="videoContainer">
        <video id="video" autoplay muted></video>
        <div id="overlay" tabindex="0"></div>
        <div id="noVideoText">å°šæœªé€£æ¥è¦–è¨Šä¾†æº</div>   
        <div id="zoomIndicator" class="zoom-indicator"></div>
    </div>

    <script>
        const connectControllerButton = document.getElementById('connectController');
        const disconnectControllerButton = document.getElementById('disconnectController');
        const connectCaptureButton = document.getElementById('connectCapture');
        const disconnectCaptureButton = document.getElementById('disconnectCapture');
        const video = document.getElementById('video');
        const videoSourceSelect = document.getElementById('videoSource');
        const resolutionSelect = document.getElementById('resolution');
        const overlay = document.getElementById('overlay');
        const ctrlAltDelButton = document.getElementById('ctrlAltDelButton');
        const winButton = document.getElementById('winButton');
        const ctrlButton = document.getElementById('ctrlButton');
        const altButton = document.getElementById('altButton');
        const fnButton = document.getElementById('fnButton');
        const releaseAllModifiersButton = document.getElementById('releaseAllModifiers');
        const fnKeysPopup = document.getElementById('fnKeysPopup');
        const screenshotButton = document.getElementById('screenshot');
        const startRecordButton = document.getElementById('startRecord');
        const stopRecordButton = document.getElementById('stopRecord');
        const recordingTimeDisplay = document.getElementById('recordingTime');
        const pressedModifiers = new Set();
        const modifierKeys = {
            ControlLeft: 'Control',
            ControlRight: 'Control',
            AltLeft: 'Alt',
            AltRight: 'Alt',
            MetaLeft: 'Meta',
            MetaRight: 'Meta',
            ShiftLeft: 'Shift',
            ShiftRight: 'Shift'
        };
        const pressedKeys = new Set();   
        const pasteTextButton = document.getElementById('pasteText');
        const pasteDialog = document.getElementById('pasteDialog');
        const pasteArea = document.getElementById('pasteArea');
        const startPasteButton = document.getElementById('startPaste');
        const pausePasteButton = document.getElementById('pausePaste');
        const cancelPasteButton = document.getElementById('cancelPaste');
        const pasteProgress = document.getElementById('pasteProgress');
        const pasteStatus = document.getElementById('pasteStatus');
        const pasteTotal = document.getElementById('pasteTotal');
        const pastePercent = document.getElementById('pastePercent');
        const keyboardMap = {
            'a': 'KeyA', 'b': 'KeyB', 'c': 'KeyC', 'd': 'KeyD', 'e': 'KeyE',
            'f': 'KeyF', 'g': 'KeyG', 'h': 'KeyH', 'i': 'KeyI', 'j': 'KeyJ',
            'k': 'KeyK', 'l': 'KeyL', 'm': 'KeyM', 'n': 'KeyN', 'o': 'KeyO',
            'p': 'KeyP', 'q': 'KeyQ', 'r': 'KeyR', 's': 'KeyS', 't': 'KeyT',
            'u': 'KeyU', 'v': 'KeyV', 'w': 'KeyW', 'x': 'KeyX', 'y': 'KeyY',
            'z': 'KeyZ',
            '1': 'Digit1', '2': 'Digit2', '3': 'Digit3', '4': 'Digit4', '5': 'Digit5',
            '6': 'Digit6', '7': 'Digit7', '8': 'Digit8', '9': 'Digit9', '0': 'Digit0',
            '-': 'Minus', '=': 'Equal',
            '[': 'BracketLeft', ']': 'BracketRight',
            '\\': 'Backslash',
            ';': 'Semicolon', "'": 'Quote',
            ',': 'Comma', '.': 'Period',
            '/': 'Slash', '`': 'Backquote',
            ' ': 'Space'
        };
        const needsShift = new Set([
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
            '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+',
            '{', '}', '|', ':', '"', '<', '>', '?'
        ]);
        const WHEEL_DELAY = 50; // å»¶é² 50ms
        const ZOOM_STEP = 0.25;
        const ZOOM_MAX = 3; // æœ€å¤§æ”¾å¤§å€ç‡ 300%
        const ZOOM_MIN = 1; // æœ€å°æ”¾å¤§å€ç‡ 100%
        const zoomInButton = document.getElementById('zoomIn');
        const zoomOutButton = document.getElementById('zoomOut');
        const videoContainer = document.getElementById('videoContainer');
        const videoElement = document.getElementById('video');
        const overlayElement = document.getElementById('overlay');
        // å®šç¾©æ›è¡Œæ¨¡å¼
        const LINE_ENDING_MODES = {
            CRLF: '\r\n',
            CR: '\r',
            LF: '\n'
        };

        
        let currentLineEnding = LINE_ENDING_MODES.CRLF; // é è¨­ä½¿ç”¨ CRLF
        let currentZoom = 1;
        let videoStream;
        let port;
        let writer;
        let isPasting = false;
        let isPausePasting = false;
        let currentPasteIndex = 0;
        let textToSend = '';
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingTimer = null;
        let recordingStartTime = null;
        let keyEventListener = null;
        let mouseMoveListener = null;
        let mouseClickListener = null; 
        let lastMouseX = null;
        let lastMouseY = null;
        let lastConsoleLogTime = 0;
        let isFnPopupVisible = false;
        let lastWheelTime = 0;
        let sharedReader = null;
        let isReading = true;  

        async function sendCtrlAltDel() {
            if (writer) {
                try {
                    // ç›´æ¥å‚³é€ç‰¹å®šçš„ Ctrl+Alt+Del å‘½ä»¤
                    await writer.write(new TextEncoder().encode('B:CTRL_ALT_DEL\n'));
                    console.log('å·²å‚³é€ Ctrl+Alt+Delete å‘½ä»¤');
                } catch (error) {
                    console.error('å‚³é€ Ctrl+Alt+Delete æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
        }

        // æ”¾å¤§å‡½æ•¸
        function zoomIn() {
            if (currentZoom < ZOOM_MAX) {
                currentZoom += ZOOM_STEP;
                applyZoom();
                showZoomIndicator(); // é¡¯ç¤ºç¸®æ”¾æŒ‡ç¤ºå™¨
            }
        }

        // ç¸®å°å‡½æ•¸
        function zoomOut() {
            if (currentZoom > ZOOM_MIN) {
                currentZoom -= ZOOM_STEP;
                applyZoom();
                showZoomIndicator(); // é¡¯ç¤ºç¸®æ”¾æŒ‡ç¤ºå™¨
            }
        }

        // å¥—ç”¨æ”¾å¤§ç¸®å°æ•ˆæœ
        function applyZoom() {
            const videoWidth = video.videoWidth * currentZoom;
            const videoHeight = video.videoHeight * currentZoom;
            
            // è¨­å®šè¦–è¨Šå’Œé®ç½©å±¤çš„è®Šæ›
            videoElement.style.transform = `scale(${currentZoom})`;
            overlayElement.style.transform = `scale(${currentZoom})`;
            
            // è¨­å®šè®Šæ›åŸé»ç‚ºå·¦ä¸Šè§’
            videoElement.style.transformOrigin = '0 0';
            overlayElement.style.transformOrigin = '0 0';
            
            // è¨ˆç®—æ”¾å¤§å¾Œçš„å°ºå¯¸
            const scaledWidth = Math.max(video.videoWidth * currentZoom, video.videoWidth);
            const scaledHeight = Math.max(video.videoHeight * currentZoom, video.videoHeight);
            
            if (currentZoom > 1) {
                // å•Ÿç”¨æ²å‹•æ¢
                videoContainer.style.overflow = 'auto';
                
                // å»ºç«‹æˆ–å–å¾—åŒ…è£å™¨
                let wrapper = videoContainer.querySelector('.zoom-wrapper');
                if (!wrapper) {
                    wrapper = document.createElement('div');
                    wrapper.className = 'zoom-wrapper';
                    // å°‡ç¾æœ‰å…ƒç´ ç§»å‹•åˆ°åŒ…è£å™¨ä¸­
                    while (videoContainer.firstChild) {
                        wrapper.appendChild(videoContainer.firstChild);
                    }
                    videoContainer.appendChild(wrapper);
                }
                
                // è¨­å®šåŒ…è£å™¨çš„å°ºå¯¸ç‚ºæ”¾å¤§å¾Œçš„å¯¦éš›å°ºå¯¸
                wrapper.style.width = `${scaledWidth}px`;
                wrapper.style.height = `${scaledHeight}px`;
                wrapper.style.position = 'absolute';
                wrapper.style.left = '0';
                wrapper.style.top = '0';
                
                // ç¢ºä¿è¦–è¨Šå’Œé®ç½©å±¤å¡«æ»¿åŒ…è£å™¨
                videoElement.style.position = 'absolute';
                overlayElement.style.position = 'absolute';
                videoElement.style.width = `${video.videoWidth}px`;
                videoElement.style.height = `${video.videoHeight}px`;
                overlayElement.style.width = `${video.videoWidth}px`;
                overlayElement.style.height = `${video.videoHeight}px`;
                
                // æ›´æ–°å®¹å™¨é¡åˆ¥
                videoContainer.classList.add('zoomed');
            } else {
                // ç¸®æ”¾æ¯”ä¾‹ç‚º 1 æ™‚ï¼Œé‚„åŸæ‰€æœ‰è¨­å®š
                videoContainer.style.overflow = 'hidden';
                videoContainer.style.display = 'flex';  // é‡è¦ï¼šæ¢å¾©ç‚º flex å¸ƒå±€
                
                const wrapper = videoContainer.querySelector('.zoom-wrapper');
                if (wrapper) {
                    while (wrapper.firstChild) {
                        videoContainer.appendChild(wrapper.firstChild);
                    }
                    wrapper.remove();
                }
                
                // é‡è¨­è¦–è¨Šå’Œé®ç½©å±¤çš„æ¨£å¼
                videoElement.style.position = 'relative';
                overlayElement.style.position = 'absolute';
                videoElement.style.width = '100%';
                videoElement.style.height = '100%';
                videoElement.style.maxWidth = '100%';  // ç¢ºä¿è¦–è¨Šä¸æœƒè¶…å‡ºå®¹å™¨
                videoElement.style.maxHeight = '100%';
                videoElement.style.transform = 'none';  // ç§»é™¤ç¸®æ”¾è®Šæ›
                overlayElement.style.transform = 'none';
                
                // æ¢å¾©åŸå§‹çš„ object-fit è¨­å®š
                videoElement.style.objectFit = 'contain';
                
                // ç§»é™¤å®¹å™¨é¡åˆ¥
                videoContainer.classList.remove('zoomed');
            }
            
            // æ›´æ–°ç¸®æ”¾æŒ‰éˆ•ç‹€æ…‹
            zoomInButton.disabled = currentZoom >= ZOOM_MAX;
            zoomOutButton.disabled = currentZoom <= ZOOM_MIN;
        }


        // æ“·åœ–åŠŸèƒ½
        async function takeScreenshot() {
            if (video.srcObject) {
                try {
                    // å»ºç«‹ canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    // åœ¨ canvas ä¸Šç¹ªè£½ç›®å‰è¦–è¨Šç•«é¢
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // è½‰æ›ç‚º blob
                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/png');
                    });
                    
                    // å»ºç«‹ä¸‹è¼‰é€£çµ
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `screenshot_${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('æ“·åœ–æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    alert('æ“·åœ–å¤±æ•—ï¼Œè«‹é‡è©¦');
                }
            }
        }


        // æª¢æŸ¥æ˜¯å¦åŒ…å«ä¸­æ—¥éŸ“æ–‡å­—
        function containsCJK(text) {
            // Unicode ç¯„åœï¼š
            // ä¸­æ–‡ï¼š\u4e00-\u9fff
            // æ—¥æ–‡å‡åï¼š\u3040-\u309f\u30a0-\u30ff
            // éŸ“æ–‡ï¼š\uac00-\ud7af\u1100-\u11ff
            const cjkRegex = /[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af\u1100-\u11ff]/;
            return cjkRegex.test(text);
        }

        // é¡¯ç¤ºç¸®æ”¾æŒ‡ç¤ºå™¨
        function showZoomIndicator() {
            const zoomIndicator = document.getElementById('zoomIndicator');
            zoomIndicator.textContent = `${Math.round(currentZoom * 100)}%`;
            zoomIndicator.classList.add('show');
            
            // æ¸…é™¤ä¹‹å‰çš„è¨ˆæ™‚å™¨ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
            if (zoomIndicator.timeoutId) {
                clearTimeout(zoomIndicator.timeoutId);
            }
            
            // è¨­ç½®è¨ˆæ™‚å™¨ï¼Œåœ¨å¹¾ç§’å¾Œéš±è—æŒ‡ç¤ºå™¨
            zoomIndicator.timeoutId = setTimeout(() => {
                zoomIndicator.classList.remove('show');
            }, 2000); // é¡¯ç¤º 2 ç§’
        }


        // é–‹å§‹éŒ„å½±
        function startRecording() {
            try {
                recordedChunks = [];
                const options = { 
                    mimeType: 'video/mp4;codecs=h264,aac'  // å˜—è©¦ä½¿ç”¨ MP4
                };

                // å¦‚æœç€è¦½å™¨ä¸æ”¯æ´ MP4 éŒ„è£½ï¼Œå›åˆ° WebM
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    console.log('MP4 æ ¼å¼ä¸æ”¯æ´ï¼Œä½¿ç”¨ WebM');
                    options.mimeType = 'video/webm;codecs=vp9';
                }

                mediaRecorder = new MediaRecorder(video.srcObject, options);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = saveRecording;
                
                mediaRecorder.start();
                startRecordButton.disabled = true;
                stopRecordButton.disabled = false;
                console.log('é–‹å§‹éŒ„å½±');

                // è¨­å®šéŒ„å½±é–‹å§‹æ™‚é–“
                recordingStartTime = Date.now();

                // é¡¯ç¤ºéŒ„å½±æ™‚é–“
                recordingTimeDisplay.style.display = 'inline'; // æˆ– 'block' æ ¹æ“šæ‚¨çš„éœ€æ±‚

                // åˆå§‹åŒ–éŒ„å½±æ™‚é–“é¡¯ç¤º
                updateRecordingTime();

                // å•Ÿå‹•å®šæ™‚å™¨ï¼Œæ¯ç§’æ›´æ–°ä¸€æ¬¡éŒ„å½±æ™‚é–“
                recordingTimer = setInterval(updateRecordingTime, 1000);

            } catch (error) {
                console.error('é–‹å§‹éŒ„å½±æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                alert('é–‹å§‹éŒ„å½±å¤±æ•—ï¼Œè«‹é‡è©¦');
            }
        }



        function highlightConnectController() {
            if (!connectControllerButton.classList.contains('highlight-button')) {
                
                // å¢åŠ é–ƒçˆæ•ˆæœ
                connectControllerButton.classList.add('highlight-button');
                
                // å»ºç«‹æç¤ºæ¡†
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.textContent = 'è«‹å…ˆé€£æ¥æ§åˆ¶å™¨æ‰èƒ½ä½¿ç”¨éµç›¤æ»‘é¼ åŠŸèƒ½ï¼';
                
                // è¨ˆç®—ä½ç½®
                const buttonRect = connectControllerButton.getBoundingClientRect();
                tooltip.style.left = `${buttonRect.left + (buttonRect.width / 2)}px`;
                tooltip.style.top = `${buttonRect.bottom + 10}px`;
                tooltip.style.transform = 'translateX(-50%)';
                
                // åŠ å…¥åˆ° body ä¸­
                document.body.appendChild(tooltip);
                
                // è¨­å®šæ™‚å™¨ç§»é™¤æ•ˆæœ
                setTimeout(() => {
                    connectControllerButton.classList.remove('highlight-button');
                    document.body.removeChild(tooltip);
                }, 3000);
            }
        }

        function checkControllerAndHighlight(event) {
            if (!port && video.srcObject) {  // å¦‚æœæ²’æœ‰é€£æ¥æ§åˆ¶å™¨ä½†æœ‰è¦–è¨Š
                event.preventDefault();  // é˜»æ­¢é è¨­è¡Œç‚º
                highlightConnectController();
            }
        }

        function updateRecordingTime() {
            const elapsedTime = Date.now() - recordingStartTime;
            const totalSeconds = Math.floor(elapsedTime / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            recordingTimeDisplay.textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // åœæ­¢éŒ„å½±
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                startRecordButton.disabled = false;
                stopRecordButton.disabled = true;
                console.log('åœæ­¢éŒ„å½±');

                // åœæ­¢å®šæ™‚å™¨
                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }

                // éš±è—éŒ„å½±æ™‚é–“
                recordingTimeDisplay.style.display = 'none';

                // é‡ç½®éŒ„å½±é–‹å§‹æ™‚é–“
                recordingStartTime = null;

                // é‡ç½®éŒ„å½±æ™‚é–“é¡¯ç¤ºå…§å®¹ï¼ˆå¯é¸ï¼‰
                recordingTimeDisplay.textContent = '00:00:00';
            }
        }


        // å„²å­˜éŒ„å½±
        function saveRecording() {
            try {
                const mimeType = mediaRecorder.mimeType;
                const blob = new Blob(recordedChunks, { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // åˆ¤æ–·æª”æ¡ˆæ ¼å¼
                const fileExt = mimeType.includes('mp4') ? 'mp4' : 'webm';
                a.download = `recording_${new Date().toISOString().replace(/[:.]/g, '-')}.${fileExt}`;
                
                if (fileExt === 'webm') {
                    alert('ç”±æ–¼ç€è¦½å™¨é™åˆ¶ï¼Œå½±ç‰‡å·²å„²å­˜ç‚º WebM æ ¼å¼ã€‚å¦‚éœ€ MP4 æ ¼å¼ï¼Œè«‹ä½¿ç”¨å½±ç‰‡è½‰æª”è»Ÿé«”é€²è¡Œè½‰æ›ã€‚');
                }
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                recordedChunks = [];
            } catch (error) {
                console.error('å„²å­˜éŒ„å½±æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                alert('å„²å­˜éŒ„å½±å¤±æ•—ï¼Œè«‹é‡è©¦');
            }
        }

        function stopVideoStream() {
            if (videoStream) {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    stopRecording();
                    clearInterval(recordingTimer);
                    recordingTimeDisplay.style.display = 'none';
                }
                videoStream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                videoStream = null;
                document.getElementById('noVideoText').style.display = 'block';
            }
            connectCaptureButton.disabled = false;
            disconnectCaptureButton.disabled = true;
            screenshotButton.disabled = true;       
            startRecordButton.disabled = true;      
            stopRecordButton.disabled = true;       
            pasteTextButton.disabled = true;
        }

        // å–å¾—è¦–è¨Šè£ç½®æ¸…å–®
        async function getVideoSources() {
            try {
                // å…ˆè«‹æ±‚æ¬Šé™
                await navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        // å–å¾—æ¬Šé™å¾Œç«‹å³åœæ­¢stream
                        stream.getTracks().forEach(track => track.stop());
                    });
                    
                // ä¹‹å¾Œå†åˆ—èˆ‰è¨­å‚™
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => {
                    if (device.kind === 'videoinput') {
                        const label = device.label.toUpperCase();
                        return (label.startsWith('USB') && 
                            /\d\.?\s*\d/.test(label) && 
                            (label.includes('HD') || label.includes('CAPTURE')));
                    }
                    return false;
                });

                if (videoDevices.length === 0) {
                    // æ²’æœ‰ç¬¦åˆçš„è£ç½®
                    videoSourceSelect.innerHTML = '<option value="">ç„¡å°æ‡‰è£ç½®</option>';
                    // åœç”¨æ‰€æœ‰è¦–è¨Šç›¸é—œæŒ‰éˆ•
                    connectCaptureButton.disabled = true;
                    disconnectCaptureButton.disabled = true;
                    screenshotButton.disabled = true;
                    startRecordButton.disabled = true;
                    stopRecordButton.disabled = true;
                    resolutionSelect.disabled = true;
                } else {
                    videoSourceSelect.innerHTML = videoDevices.map(device => {
                        let label = device.label || 'è¦–è¨Šä¾†æº';
                        label = label.replace(/\(.*?\)/g, '').trim();
                        return `<option value="${device.deviceId}">${label}</option>`;
                    }).join('');

                    // å•Ÿç”¨è¦–è¨Šé€£æ¥æŒ‰éˆ•å’Œè§£æåº¦é¸æ“‡
                    connectCaptureButton.disabled = false;
                    resolutionSelect.disabled = false;

                    const savedVideoSource = localStorage.getItem('videoSourceId');
                    const savedResolution = localStorage.getItem('resolution');

                    if (savedVideoSource && videoDevices.some(device => device.deviceId === savedVideoSource)) {
                        videoSourceSelect.value = savedVideoSource;
                    }

                    if (savedResolution) {
                        resolutionSelect.value = savedResolution;
                    }
                }
            } catch (error) {
                console.error('å–å¾—è¦–è¨Šä¾†æºæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                alert('è«‹å…è¨±è¦–è¨Šæ¬Šé™ä»¥ä½¿ç”¨æ­¤åŠŸèƒ½');
            }
        }

        async function startVideoStream() {
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            const selectedDeviceId = videoSourceSelect.value;
            const [width, height] = resolutionSelect.value.split('x').map(Number);

            const constraints = {
                video: {
                    deviceId: { exact: selectedDeviceId },
                    width: { exact: width },  // ä¿æŒ exact ä»¥ç¢ºä¿å–å¾—æ­£ç¢ºçš„è§£æåº¦
                    height: { exact: height }
                }
            };

            try {
                videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = videoStream;
                document.getElementById('noVideoText').style.display = 'none'; 

                video.onloadedmetadata = () => {
                    connectCaptureButton.disabled = true;
                    disconnectCaptureButton.disabled = false;
                    screenshotButton.disabled = false;      
                    startRecordButton.disabled = false;     
                    stopRecordButton.disabled = true;       

                    localStorage.setItem('videoSourceId', selectedDeviceId);
                    localStorage.setItem('resolution', resolutionSelect.value);
                };
            } catch (error) {
                console.error('é–‹å§‹è¦–è¨Šä¸²æµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                
                if (error.name === 'OverconstrainedError') {
                    // å‘ŠçŸ¥ç”¨æˆ¶ç›®å‰è§£æåº¦ä¸æ”¯æ´
                    alert(`æ­¤è£ç½®ä¸æ”¯æ´ ${width}x${height} è§£æåº¦`);
                    
                    // å˜—è©¦åˆ‡æ›åˆ°è¼ƒä½çš„è§£æåº¦
                    const resolutions = ['1920x1080', '1366x768', '1280x720'];
                    let foundSupportedResolution = false;

                    for (const res of resolutions) {
                        if (res === resolutionSelect.value) continue; // è·³éå¤±æ•—çš„è§£æåº¦
                        
                        resolutionSelect.value = res;
                        const [newWidth, newHeight] = res.split('x').map(Number);
                        
                        try {
                            const newConstraints = {
                                video: {
                                    deviceId: { exact: selectedDeviceId },
                                    width: { exact: newWidth },
                                    height: { exact: newHeight }
                                }
                            };
                            
                            videoStream = await navigator.mediaDevices.getUserMedia(newConstraints);
                            video.srcObject = videoStream;
                            document.getElementById('noVideoText').style.display = 'none';
                            
                            connectCaptureButton.disabled = true;
                            disconnectCaptureButton.disabled = false;
                            screenshotButton.disabled = false;
                            startRecordButton.disabled = false;
                            stopRecordButton.disabled = true;
                            
                            localStorage.setItem('videoSourceId', selectedDeviceId);
                            localStorage.setItem('resolution', res);
                            
                            foundSupportedResolution = true;
                            alert(`å·²è‡ªå‹•åˆ‡æ›åˆ°æ”¯æ´çš„è§£æåº¦: ${res}`);
                            break;
                        } catch (e) {
                            console.error(`è§£æåº¦ ${res} ä¹Ÿä¸æ”¯æ´:`, e);
                        }
                    }
                    
                    if (!foundSupportedResolution) {
                        alert('ç„¡æ³•æ‰¾åˆ°æ”¯æ´çš„è§£æåº¦ï¼Œè«‹æ‰‹å‹•é¸æ“‡å…¶ä»–è§£æåº¦è©¦è©¦ã€‚');
                    }
                } else if (error.name === 'NotAllowedError') {
                    alert('è«‹å…è¨±è¦–è¨Šæ¬Šé™ä»¥ä½¿ç”¨æ­¤åŠŸèƒ½');
                } else if (error.name === 'NotFoundError') {
                    alert('æ‰¾ä¸åˆ°æŒ‡å®šçš„è¦–è¨Šè£ç½®');
                } else if (error.name === 'NotReadableError') {
                    alert('ç„¡æ³•å­˜å–è¦–è¨Šè£ç½®ï¼Œå¯èƒ½è¢«å…¶ä»–ç¨‹å¼ä½”ç”¨');
                } else {
                    alert('è¦–è¨Šå•Ÿå‹•å¤±æ•—ï¼š' + error.message);
                }
            }
        }
            
    
        async function connectController() {
            if ('serial' in navigator) {
                try {
                    const filters = [{
                        usbVendorId: 0x2341,
                        usbProductId: 0x8036
                    }];

                    port = await navigator.serial.requestPort({ filters });
                    await port.open({ baudRate: 115200 });

                    connectControllerButton.disabled = true;
                    disconnectControllerButton.disabled = false;

                    addEventListeners();
                    overlay.focus();

                    ctrlAltDelButton.disabled = false;
                    winButton.disabled = false;
                    ctrlButton.disabled = false;
                    altButton.disabled = false;
                    fnButton.disabled = false;
                    releaseAllModifiersButton.disabled = false;
                    pasteTextButton.disabled = false;


                    // æ›´æ–°çµ‚ç«¯æ©ŸæŒ‰éˆ•ç‹€æ…‹ï¼Œä½†ä¿æŒæ›è¡Œæ¨¡å¼å¯é¸
                    updateTerminalButtonStates(true);
                            
                    // ç¢ºä¿æ›è¡Œæ¨¡å¼é¸æ“‡å™¨ä¿æŒå•Ÿç”¨
                    const lineEndingMode = document.getElementById('lineEndingMode');
                    if (lineEndingMode) {
                        lineEndingMode.disabled = false;
                    }

                } catch (error) {
                    console.error('é€£æ¥æ§åˆ¶å™¨æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    
                    // æ ¹æ“šéŒ¯èª¤é¡å‹é¡¯ç¤ºä¸åŒè¨Šæ¯
                    if (error.name === 'NetworkError') {
                        alert('ç„¡æ³•é–‹å•Ÿåºåˆ—åŸ ï¼Œå¯èƒ½è¢«å…¶ä»–ç¨‹å¼ä½”ç”¨ä¸­ã€‚è«‹é—œé–‰å…¶ä»–ä½¿ç”¨æ­¤è£ç½®çš„ç¨‹å¼å¾Œå†è©¦ã€‚');
                    } else {
                        alert('é€£æ¥æ§åˆ¶å™¨æ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message);
                    }
                }
            } else {
                alert('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´ Web Serial API');
            }
        }
    
     
        async function disconnectController() {
            
            isReading = false;

            await new Promise(resolve => setTimeout(resolve, 100));

            if (writer) {
                try {
                    // ä¸­æ–·å‰å‚³é€ RELEASE_ALL
                    await writer.write(new TextEncoder().encode('B:RELEASE_ALL\n'));
                    writer.releaseLock();
                } catch (error) {
                    console.error('å‚³é€ RELEASE_ALL å‘½ä»¤æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
                writer = null;
            }

            try {
                if (sharedReader) {
                    await sharedReader.cancel();
                    if (sharedReader.locked) {
                        sharedReader.releaseLock();
                    }
                    sharedReader = null;
                }

                if (port) {
                    await port.close();
                    port = null;
                }
            } catch (error) {
                console.error('é—œé–‰é€£æ¥æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
            }

            // é‡ç½®æ‰€æœ‰æŒ‰éˆ•ç‹€æ…‹
            connectControllerButton.disabled = false;
            disconnectControllerButton.disabled = true;

            removeEventListeners();
            await resetButtonStates();

            ctrlAltDelButton.disabled = true;
            winButton.disabled = true;
            ctrlButton.disabled = true;
            altButton.disabled = true;
            fnButton.disabled = true;
            releaseAllModifiersButton.disabled = true;
            pasteTextButton.disabled = true;

            // æ›´æ–°çµ‚ç«¯æ©Ÿçš„æŒ‰éˆ•ç‹€æ…‹
            const terminalConnect = document.getElementById('terminalConnect');
            const terminalClear = document.getElementById('terminalClear');
            const terminalBaudRate = document.getElementById('terminalBaudRate');

            if (terminalConnect) terminalConnect.disabled = false;
            if (terminalClear) terminalClear.disabled = true;
            if (terminalBaudRate) terminalBaudRate.disabled = false;

            // å¦‚æœçµ‚ç«¯æ©Ÿå·²ç¶“æ‰“é–‹ï¼Œæ›´æ–°å…¶ç‹€æ…‹
            if (window.term) {
                term.writeln('Disconnected from serial port');
            }

            closeFnPopup();
            lastMouseX = null;
            lastMouseY = null;
            }


    
        function addEventListeners() {
            keyEventListener = (event) => sendKeyToArduino(event);
            overlay.addEventListener('keydown', keyEventListener);
            overlay.addEventListener('keyup', keyEventListener);
    
            mouseMoveListener = (event) => sendMouseMovementToArduino(event);
            overlay.addEventListener('mousemove', mouseMoveListener);
    
            mouseClickListener = (event) => sendMouseClickToArduino(event);
            overlay.addEventListener('mousedown', mouseClickListener);
            overlay.addEventListener('mouseup', mouseClickListener);
            
            overlay.addEventListener('wheel', handleMouseWheel);

           
            ctrlAltDelButton.addEventListener('click', sendCtrlAltDel);
            winButton.addEventListener('click', toggleWinKey);
            ctrlButton.addEventListener('click', toggleCtrlKey);
            altButton.addEventListener('click', toggleAltKey);
            fnButton.addEventListener('click', toggleFnKeys);
            releaseAllModifiersButton.addEventListener('click', releaseAllModifiers);
    
            pasteTextButton.addEventListener('click', () => {
                pasteDialog.style.display = 'block';
                pasteArea.value = '';
                pasteProgress.style.display = 'none';
                isPasting = false;
                isPausePasting = false;
            });

            cancelPasteButton.addEventListener('click', () => {
                pasteDialog.style.display = 'none';
                if (isPasting) {
                    isPasting = false;
                    isPausePasting = false;
                }
            });

            pausePasteButton.addEventListener('click', () => {
                if (isPasting) {
                    isPausePasting = !isPausePasting;
                    pausePasteButton.textContent = isPausePasting ? 'ç¹¼çºŒ' : 'æš«åœ';
                }
            });

            startPasteButton.addEventListener('click', async () => {
                if (!port) {
                    alert('è«‹å…ˆé€£æ¥æ§åˆ¶å™¨');
                    return;
                }

                textToSend = pasteArea.value;
                if (!textToSend) {
                    alert('è«‹è¼¸å…¥è¦å‚³é€çš„æ–‡å­—');
                    return;
                }

                // æª¢æŸ¥æ˜¯å¦åŒ…å«ä¸­æ—¥éŸ“æ–‡å­—
                if (containsCJK(textToSend)) {
                    if (!confirm('æª¢æ¸¬æ–‡å­—ä¸­åŒ…å«ä¸­æ–‡ã€æ—¥æ–‡æˆ–éŸ“æ–‡å­—å…ƒï¼Œé€™äº›å­—å…ƒå°‡ç„¡æ³•æ­£ç¢ºå‚³é€ã€‚\n\nè¦ç¹¼çºŒå‚³é€å—ï¼Ÿï¼ˆä¸æ”¯æ´çš„å­—å…ƒå°‡è¢«è·³éï¼‰')) {
                        return;
                    }
                }

                if (!isPasting) {
                    isPasting = true;
                    currentPasteIndex = 0;
                    pasteProgress.style.display = 'block';
                    pasteTotal.textContent = textToSend.length;
                    startPasteButton.disabled = true;
                    pasteArea.disabled = true;

                    sendTextByChar();
                }
            });

            overlay.addEventListener('mouseleave', handleMouseLeave);
    

            overlay.addEventListener('keydown', (event) => {
                // Windows çš„ Ctrl + A
                // macOS çš„ Command + A (metaKey)
                if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'a') {
                    event.preventDefault();
                    console.log('é˜»æ­¢å…¨é¸äº‹ä»¶');
                }
            });

            document.querySelectorAll('.fn-key').forEach(button => {
                button.addEventListener('click', () => {
                    handleFnKeyPress(button.dataset.key);
                });
            });

        }

        // è¦–è¨Šé€£æ¥æŒ‰éˆ•çš„æç¤ºå‡½æ•¸
        function highlightConnectCapture() {
            if (!connectCaptureButton.classList.contains('highlight-button')) {
                // å¢åŠ é–ƒçˆæ•ˆæœ
                connectCaptureButton.classList.add('highlight-button');
                
                // å»ºç«‹æç¤ºæ¡†
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.textContent = 'è«‹å…ˆé€£æ¥è¦–è¨Šç•«é¢ï¼Œå†é€£æ¥æ§åˆ¶å™¨ã€‚';
                
                // è¨ˆç®—ä½ç½®
                const buttonRect = connectCaptureButton.getBoundingClientRect();
                tooltip.style.left = `${buttonRect.left + (buttonRect.width / 2)}px`;
                tooltip.style.top = `${buttonRect.bottom + 10}px`;
                tooltip.style.transform = 'translateX(-50%)';
                
                // åŠ å…¥åˆ° body ä¸­
                document.body.appendChild(tooltip);
                
                // è¨­å®šæ™‚å™¨ç§»é™¤æ•ˆæœ
                setTimeout(() => {
                    connectCaptureButton.classList.remove('highlight-button');
                    document.body.removeChild(tooltip);
                }, 3000);
            }
        }


        function removeEventListeners() {
            if (keyEventListener) {
                overlay.removeEventListener('keydown', keyEventListener);
                overlay.removeEventListener('keyup', keyEventListener);
                keyEventListener = null;
            }
    
            if (mouseMoveListener) {
                overlay.removeEventListener('mousemove', mouseMoveListener);
                mouseMoveListener = null;
            }
    
            if (mouseClickListener) {
                overlay.removeEventListener('mousedown', mouseClickListener);
                overlay.removeEventListener('mouseup', mouseClickListener);
                mouseClickListener = null;
            }
    
            overlay.removeEventListener('wheel', handleMouseWheel);

            ctrlAltDelButton.removeEventListener('click', sendCtrlAltDel);
            winButton.removeEventListener('click', toggleWinKey);
            ctrlButton.removeEventListener('click', toggleCtrlKey);
            altButton.removeEventListener('click', toggleAltKey);
            fnButton.removeEventListener('click', toggleFnKeys);
            releaseAllModifiersButton.removeEventListener('click', releaseAllModifiers);
       
            overlay.removeEventListener('mouseleave', handleMouseLeave);
    
            document.querySelectorAll('.fn-key').forEach(button => {
                button.removeEventListener('click', () => {
                    handleFnKeyPress(button.dataset.key);
                });
            });
        }

        async function sendTextByChar() {
            if (!isPasting || !port) {
                resetPasteStatus();
                return;
            }

            if (isPausePasting) {
                setTimeout(sendTextByChar, 100);
                return;
            }

            if (currentPasteIndex >= textToSend.length) {
                resetPasteStatus();
                pasteDialog.style.display = 'none';
                return;
            }

            try {
                const char = textToSend[currentPasteIndex];
                const DELAY = 10; // å¢åŠ å»¶é²æ™‚é–“åˆ° 50ms

                async function sendKeyStrokes(keystrokes) {
                    for (const stroke of keystrokes) {
                        try {
                            await safeWrite(stroke + '\n');
                            // æ¯å€‹æŒ‰éµæ“ä½œä¹‹é–“å»¶é²ä¸€ä¸‹
                            await new Promise(resolve => setTimeout(resolve, DELAY));
                        } catch (error) {
                            console.error('å‚³é€æŒ‰éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                            throw error;
                        }
                    }
                }

                function getKeyStrokes(char) {
                    // åˆ¤æ–·æ˜¯å¦éœ€è¦ Shift
                    let needShift = char >= 'A' && char <= 'Z' || "~!@#$%^&*()_+{}|:\"<>?".includes(char);
                    
                    let keyCode;
                    switch (char) {
                        // ç‰¹æ®Šç¬¦è™Ÿçš„å°æ‡‰
                        case '!': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit1', 'B:KEY_UP Digit1', 'B:MOD_UP Shift'] : null;
                        case '@': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit2', 'B:KEY_UP Digit2', 'B:MOD_UP Shift'] : null;
                        case '#': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit3', 'B:KEY_UP Digit3', 'B:MOD_UP Shift'] : null;
                        case '$': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit4', 'B:KEY_UP Digit4', 'B:MOD_UP Shift'] : null;
                        case '%': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit5', 'B:KEY_UP Digit5', 'B:MOD_UP Shift'] : null;
                        case '^': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit6', 'B:KEY_UP Digit6', 'B:MOD_UP Shift'] : null;
                        case '&': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit7', 'B:KEY_UP Digit7', 'B:MOD_UP Shift'] : null;
                        case '*': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit8', 'B:KEY_UP Digit8', 'B:MOD_UP Shift'] : null;
                        case '(': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit9', 'B:KEY_UP Digit9', 'B:MOD_UP Shift'] : null;
                        case ')': return needShift ? ['B:MOD_DOWN Shift', 'B:KEY_DOWN Digit0', 'B:KEY_UP Digit0', 'B:MOD_UP Shift'] : null;
                        
                        // æ¨™é»ç¬¦è™Ÿ
                        case '_': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Minus', 'B:KEY_UP Minus', 'B:MOD_UP Shift'];
                        case '+': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Equal', 'B:KEY_UP Equal', 'B:MOD_UP Shift'];
                        case '{': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN BracketLeft', 'B:KEY_UP BracketLeft', 'B:MOD_UP Shift'];
                        case '}': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN BracketRight', 'B:KEY_UP BracketRight', 'B:MOD_UP Shift'];
                        case '|': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Backslash', 'B:KEY_UP Backslash', 'B:MOD_UP Shift'];
                        case ':': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Semicolon', 'B:KEY_UP Semicolon', 'B:MOD_UP Shift'];
                        case '"': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Quote', 'B:KEY_UP Quote', 'B:MOD_UP Shift'];
                        case '<': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Comma', 'B:KEY_UP Comma', 'B:MOD_UP Shift'];
                        case '>': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Period', 'B:KEY_UP Period', 'B:MOD_UP Shift'];
                        case '?': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Slash', 'B:KEY_UP Slash', 'B:MOD_UP Shift'];
                        case '~': return ['B:MOD_DOWN Shift', 'B:KEY_DOWN Backquote', 'B:KEY_UP Backquote', 'B:MOD_UP Shift'];

                        // åŸºæœ¬ç¬¦è™Ÿ
                        case '-': return ['B:KEY_DOWN Minus', 'B:KEY_UP Minus'];
                        case '=': return ['B:KEY_DOWN Equal', 'B:KEY_UP Equal'];
                        case '[': return ['B:KEY_DOWN BracketLeft', 'B:KEY_UP BracketLeft'];
                        case ']': return ['B:KEY_DOWN BracketRight', 'B:KEY_UP BracketRight'];
                        case '\\': return ['B:KEY_DOWN Backslash', 'B:KEY_UP Backslash'];
                        case ';': return ['B:KEY_DOWN Semicolon', 'B:KEY_UP Semicolon'];
                        case "'": return ['B:KEY_DOWN Quote', 'B:KEY_UP Quote'];
                        case ',': return ['B:KEY_DOWN Comma', 'B:KEY_UP Comma'];
                        case '.': return ['B:KEY_DOWN Period', 'B:KEY_UP Period'];
                        case '/': return ['B:KEY_DOWN Slash', 'B:KEY_UP Slash'];
                        case '`': return ['B:KEY_DOWN Backquote', 'B:KEY_UP Backquote'];
                        case ' ': return ['B:KEY_DOWN Space', 'B:KEY_UP Space'];

                        // æ›è¡Œè™•ç†
                        case '\n':
                        case '\r':
                            return ['B:KEY_DOWN Enter', 'B:KEY_UP Enter'];

                        default:
                            if (char >= 'A' && char <= 'Z') {
                                return [
                                    'B:MOD_DOWN Shift',
                                    `B:KEY_DOWN Key${char}`,
                                    `B:KEY_UP Key${char}`,
                                    'B:MOD_UP Shift'
                                ];
                            } else if (char >= 'a' && char <= 'z') {
                                return [
                                    `B:KEY_DOWN Key${char.toUpperCase()}`,
                                    `B:KEY_UP Key${char.toUpperCase()}`
                                ];
                            } else if (char >= '0' && char <= '9') {
                                return [
                                    `B:KEY_DOWN Digit${char}`,
                                    `B:KEY_UP Digit${char}`
                                ];
                            }
                            return null;
                    }
                }

                const keyStrokes = getKeyStrokes(char);
                if (keyStrokes) {
                    await sendKeyStrokes(keyStrokes);
                }

                currentPasteIndex++;
                pasteStatus.textContent = currentPasteIndex;
                pastePercent.textContent = Math.round((currentPasteIndex / textToSend.length) * 100);

                setTimeout(sendTextByChar, DELAY);

            } catch (error) {
                console.error('å‚³é€æ–‡å­—æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                resetPasteStatus();
                alert('å‚³é€æ–‡å­—æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹é‡è©¦');
            }
        }

   
        async function handleMouseWheel(event) {
            if (port) {
                const now = Date.now();
                if (now - lastWheelTime < WHEEL_DELAY) {
                    return;
                }
                lastWheelTime = now;

                event.preventDefault();
                const scrollAmount = -Math.sign(event.deltaY);
                
                try {
                    const data = `B:MOUSE_SCROLL ${scrollAmount}\n`;
                    await safeWrite(data);
                } catch (error) {
                    console.error('å‚³é€æ»‘é¼ æ»¾è¼ªäº‹ä»¶æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
        }

        async function sendKeyToArduino(event) {
            if (port) {
                overlay.focus();

                const type = event.type === 'keydown' ? 'KEY_DOWN' : 'KEY_UP';
                const key = event.code;

                if (type === 'KEY_DOWN') {
                    pressedKeys.add(key);
                } else {
                    pressedKeys.delete(key);
                }

                if (modifierKeys[key]) {
                    const modifier = modifierKeys[key];
                    const modType = event.type === 'keydown' ? 'MOD_DOWN' : 'MOD_UP';
                    const data = `B:${modType} ${modifier}\n`;

                    try {
                        await safeWrite(data);
                        console.log(`å·²å‚³é€ä¿®é£¾éµï¼š${data.trim()}`);
                    } catch (error) {
                        console.error('å‚³é€ä¿®é£¾éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                } else {
                    const data = `B:${type} ${key}\n`;

                    try {
                        await safeWrite(data);
                        console.log(`å·²å‚³é€æŒ‰éµï¼š${data.trim()}`);
                    } catch (error) {
                        console.error('å‚³é€æŒ‰éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                }
            }
        }
    
        async function handleVisibilityChange() {
            if (document.hidden || document.visibilityState === 'hidden') {
                if (port) {
                    try {
                        // å‚³é€ RELEASE_ALL å‘½ä»¤åˆ° Arduino
                        await safeWrite('B:RELEASE_ALL\n');
                        console.log('å·²å‚³é€ RELEASE_ALL å‘½ä»¤');
                        await releaseAllKeys();
                    } catch (error) {
                        console.error('å‚³é€ RELEASE_ALL å‘½ä»¤æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                }
            }
        }
    
        async function sendMouseMovementToArduino(event) {
            if (port) {
                const rect = video.getBoundingClientRect();
                const videoAspectRatio = video.videoWidth / video.videoHeight;
                const elementAspectRatio = rect.width / rect.height;

                let videoDisplayWidth, videoDisplayHeight;
                let offsetX, offsetY;

                if (videoAspectRatio > elementAspectRatio) {
                    videoDisplayWidth = rect.width;
                    videoDisplayHeight = rect.width / videoAspectRatio;
                    offsetX = rect.left;
                    offsetY = rect.top + (rect.height - videoDisplayHeight) / 2;
                } else {
                    videoDisplayWidth = rect.height * videoAspectRatio;
                    videoDisplayHeight = rect.height;
                    offsetX = rect.left + (rect.width - videoDisplayWidth) / 2;
                    offsetY = rect.top;
                }

                const mouseX = (event.clientX - offsetX);
                const mouseY = (event.clientY - offsetY);

                if (mouseX >= 0 && mouseX <= videoDisplayWidth && mouseY >= 0 && mouseY <= videoDisplayHeight) {
                    const relativeX = mouseX / videoDisplayWidth;
                    const relativeY = mouseY / videoDisplayHeight;

                    const absoluteX = Math.round((relativeX * 2 - 1) * 32767);
                    const absoluteY = Math.round((relativeY * 2 - 1) * 32767);

                    const currentTime = Date.now();

                    if (currentTime - lastConsoleLogTime >= 1000) {
                        console.log(`è¨ˆç®—å¾Œçš„çµ•å°åº§æ¨™ï¼šX=${absoluteX}, Y=${absoluteY}`);
                        lastConsoleLogTime = currentTime;
                    }

                    if (lastMouseX !== absoluteX || lastMouseY !== absoluteY) {
                        const data = `B:MOUSE_MOVE_TO ${absoluteX} ${absoluteY}\n`;

                        try {
                            await safeWrite(data);
                            lastMouseX = absoluteX;
                            lastMouseY = absoluteY;
                        } catch (error) {
                            console.error('å‚³é€æ»‘é¼ çµ•å°ä½ç½®æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                        }
                    }
                }
            }
        }
    
        async function sendMouseClickToArduino(event) {
            if (port) {
                event.preventDefault();
                const type = event.type === 'mousedown' ? 'MOUSE_DOWN' : 'MOUSE_UP';
                let button = '';
                if (event.button === 0) button = 'LEFT';
                else if (event.button === 1) button = 'MIDDLE';
                else if (event.button === 2) button = 'RIGHT';

                const data = `B:${type} ${button}\n`;

                try {
                    await safeWrite(data);
                    console.log(`å·²å‚³é€æ»‘é¼ é»æ“Šï¼š${data.trim()}`);
                } catch (error) {
                    console.error('å‚³é€æ»‘é¼ é»æ“Šæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
        }
    
        function handleMouseLeave() {
            lastMouseX = null;
            lastMouseY = null;
        }
    
        async function sendCtrlAltDel() {
            if (port) {
                try {
                    await safeWrite('B:KEY_DOWN Control\n');
                    await safeWrite('B:KEY_DOWN Alt\n');
                    await safeWrite('B:KEY_DOWN Delete\n');
                    await new Promise(resolve => setTimeout(resolve, 100));
                    await safeWrite('B:KEY_UP Delete\n');
                    await safeWrite('B:KEY_UP Alt\n');
                    await safeWrite('B:KEY_UP Control\n');
                    console.log('å·²å‚³é€ Ctrl+Alt+Delete');
                } catch (error) {
                    console.error('å‚³é€ Ctrl+Alt+Delete æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
        }
    
        async function toggleWinKey() {
            if (port) {
                if (pressedModifiers.has('Meta')) {
                    try {
                        await safeWrite('B:KEY_UP Meta\n');
                        console.log('å·²é‡‹æ”¾ Win éµ');
                        pressedModifiers.delete('Meta');
                        winButton.classList.remove('active');
                    } catch (error) {
                        console.error('é‡‹æ”¾ Win éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                } else {
                    try {
                        await safeWrite('B:KEY_DOWN Meta\n');
                        console.log('å·²æŒ‰ä¸‹ Win éµ');
                        pressedModifiers.add('Meta');
                        winButton.classList.add('active');
                    } catch (error) {
                        console.error('æŒ‰ä¸‹ Win éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                }
            }
        }

        async function toggleCtrlKey() {
            if (port) {
                if (pressedModifiers.has('Control')) {
                    try {
                        await safeWrite('B:KEY_UP Control\n');
                        console.log('å·²é‡‹æ”¾ Ctrl éµ');
                        pressedModifiers.delete('Control');
                        ctrlButton.classList.remove('active');
                    } catch (error) {
                        console.error('é‡‹æ”¾ Ctrl éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                } else {
                    try {
                        await safeWrite('B:KEY_DOWN Control\n');
                        console.log('å·²æŒ‰ä¸‹ Ctrl éµ');
                        pressedModifiers.add('Control');
                        ctrlButton.classList.add('active');
                    } catch (error) {
                        console.error('æŒ‰ä¸‹ Ctrl éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                }
            }
        }

        async function toggleAltKey() {
            if (port) {
                if (pressedModifiers.has('Alt')) {
                    try {
                        await safeWrite('B:KEY_UP Alt\n');
                        console.log('å·²é‡‹æ”¾ Alt éµ');
                        pressedModifiers.delete('Alt');
                        altButton.classList.remove('active');
                    } catch (error) {
                        console.error('é‡‹æ”¾ Alt éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                } else {
                    try {
                        await safeWrite('B:KEY_DOWN Alt\n');
                        console.log('å·²æŒ‰ä¸‹ Alt éµ');
                        pressedModifiers.add('Alt');
                        altButton.classList.add('active');
                    } catch (error) {
                        console.error('æŒ‰ä¸‹ Alt éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                }
            }
        }

        function toggleFnKeys(event) {
            if (!isFnPopupVisible) {
                const buttonRect = fnButton.getBoundingClientRect();
                fnKeysPopup.style.display = 'grid';
                fnKeysPopup.style.top = `${buttonRect.bottom + 5}px`;
                fnKeysPopup.style.left = `${buttonRect.left}px`;
                isFnPopupVisible = true;
                fnButton.classList.add('active');
            } else {
                closeFnPopup();
            }
        }

        function resetPasteStatus() {
            isPasting = false;
            isPausePasting = false;
            currentPasteIndex = 0;
            startPasteButton.disabled = false;
            pasteArea.disabled = false;
            pausePasteButton.textContent = 'æš«åœ';
            //pasteArea.value = '';  // æ¸…ç©ºæ–‡å­—å€åŸŸ
        }

        async function handleFnKeyPress(key) {
            if (port) {
                try {
                    await safeWrite(`B:KEY_DOWN ${key}\n`);
                    await new Promise(resolve => setTimeout(resolve, 50));
                    await safeWrite(`B:KEY_UP ${key}\n`);
                    console.log(`å·²å‚³é€åŠŸèƒ½éµï¼š${key}`);
                } catch (error) {
                    console.error(`å‚³é€åŠŸèƒ½éµ ${key} æ™‚ç™¼ç”ŸéŒ¯èª¤:`, error);
                }
            }
            closeFnPopup();
        }

        function closeFnPopup() {
            fnKeysPopup.style.display = 'none';
            isFnPopupVisible = false;
            fnButton.classList.remove('active');
        }

        // è¦–çª—æ‹–æ›³åŠŸèƒ½
        function makeWindowDraggable(windowElement, headerElement) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            
            headerElement.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e.preventDefault();
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                e.preventDefault();
                
                const windowRect = windowElement.getBoundingClientRect();
                const containerRect = document.getElementById('videoContainer').getBoundingClientRect();
                const headerHeight = document.getElementById('terminalHeader').offsetHeight;

                // è¨ˆç®—æ–°ä½ç½®
                const newLeft = windowElement.offsetLeft + e.clientX - pos3;
                const newTop = windowElement.offsetTop + e.clientY - pos4;

                // è¨­å®šé‚Šç•Œé™åˆ¶
                const maxLeft = containerRect.width - windowRect.width;

                // ä¿®æ­£ä¸‹é‚Šç•Œè¨ˆç®—ï¼Œæ¸›å»æ¨™é¡Œæ¬„é«˜åº¦
                const maxTop = containerRect.height - windowRect.height + headerHeight;

                // é™åˆ¶åœ¨è¦–çª—å®¹å™¨å…§
                windowElement.style.left = `${Math.min(Math.max(0, newLeft), maxLeft)}px`;
                windowElement.style.top = `${Math.min(Math.max(0, newTop), maxTop)}px`;

                pos3 = e.clientX;
                pos4 = e.clientY;
            }

            function closeDragElement() {
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        async function releaseAllModifiers() {
            if (port) {
                try {
                    await safeWrite('B:RELEASE_ALL\n');
                    console.log('å·²å‚³é€ RELEASE_ALL å‘½ä»¤');
                    pressedModifiers.clear();
                    winButton.classList.remove('active');
                    ctrlButton.classList.remove('active');
                    altButton.classList.remove('active');
                } catch (error) {
                    console.error('å‚³é€ RELEASE_ALL å‘½ä»¤æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
        }

        async function releaseAllKeys() {
            if (port) {
                try {
                    await safeWrite('B:RELEASE_ALL\n');
                    console.log('å·²å‚³é€ RELEASE_ALL å‘½ä»¤');

                    pressedKeys.clear();
                    pressedModifiers.clear();
                    winButton.classList.remove('active');
                    ctrlButton.classList.remove('active');
                    altButton.classList.remove('active');
                } catch (error) {
                    console.error('é‡‹æ”¾æ‰€æœ‰æŒ‰éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
        }

        async function resetButtonStates() {
            if (pressedModifiers.size > 0) {
                if (writer) {
                    await releaseAllModifiers();
                } else {
                    pressedModifiers.clear();
                    winButton.classList.remove('active');
                    ctrlButton.classList.remove('active');
                    altButton.classList.remove('active');
                }
            }
        }

       
        function updateTerminalButtonStates(isConnected) {
            const terminalConnect = document.getElementById('terminalConnect');
            const terminalClear = document.getElementById('terminalClear');
            const terminalDownload = document.getElementById('terminalDownload');
            const terminalBaudRate = document.getElementById('terminalBaudRate');
            const lineEndingMode = document.getElementById('lineEndingMode');

            if (terminalConnect) terminalConnect.disabled = isConnected;
            if (terminalClear) terminalClear.disabled = !isConnected;
            if (terminalDownload) terminalDownload.disabled = !isConnected;
            //if (terminalBaudRate) terminalBaudRate.disabled = isConnected;
            //if (lineEndingMode) lineEndingMode.disabled = isConnected;
        }

        function updateMainControllerButtons(isConnected) {
            const connectController = document.getElementById('connectController');
            const disconnectController = document.getElementById('disconnectController');

            if (connectController) connectController.disabled = isConnected;
            if (disconnectController) disconnectController.disabled = !isConnected;
        }

        function setupTerminalEventListeners() {
            // ç›£è½é€Ÿç‡è®Šæ›´
            const baudRateSelect = document.getElementById('terminalBaudRate');
            if (baudRateSelect) {
                baudRateSelect.addEventListener('change', async (e) => {
                    if (port) {
                        const baudRate = parseInt(e.target.value);
                        try {
                            await safeWrite(`R:BAUD=${baudRate}\n`);
                            if (window.term) {
                                term.writeln(`RS232 baud rate changed to ${baudRate}`);
                            }
                        } catch (error) {
                            console.error('è®Šæ›´é€Ÿç‡æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                            if (window.term) {
                                term.writeln(`Failed to change baud rate: ${error.message}`);
                            }
                        }
                    }
                });
            }
            
            const terminalClear = document.getElementById('terminalClear');
            if (terminalClear) {
                terminalClear.addEventListener('click', () => {
                    if (window.term) {
                        window.term.clear();
                    }
                });
            }
        }
    
      
        // é‡‹æ”¾ Writer çš„è¼”åŠ©å‡½æ•¸
        async function releaseWriter() {
            if (writer) {
                try {
                    await writer.close();
                    writer.releaseLock();
                } catch (error) {
                    console.error('é‡‹æ”¾ writer æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
                writer = null;
            }
        }

        async function safeWrite(data) {
            if (!port) return;
            
            let tempWriter = null;
            try {
                if (writer) {
                    writer.releaseLock();
                    writer = null;
                }
                tempWriter = port.writable.getWriter();
                await tempWriter.write(new TextEncoder().encode(data));
            } catch (error) {
                console.error('å¯«å…¥è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
            } finally {
                if (tempWriter) {
                    try {
                        tempWriter.releaseLock();
                    } catch (error) {
                        console.error('é‡‹æ”¾ writer æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                }
            }
        }

      
        function initializeTerminal() {
            // å»ºç«‹çµ‚ç«¯æ©Ÿå€‹é«”
            window.term = new Terminal({
                cursorBlink: true,
                cursorStyle: 'block',
                fontSize: 14,
                fontFamily: 'monospace',
                theme: {
                    background: '#000',
                    foreground: '#00ff00'
                }
            });

            const fitAddon = new FitAddon.FitAddon();
            term.loadAddon(fitAddon);
            term.open(document.getElementById('terminal-container'));
            fitAddon.fit();


            const lineEndingSelect = document.getElementById('lineEndingMode');
            // è¼‰å…¥å„²å­˜çš„æ›è¡Œæ¨¡å¼
            const savedLineEnding = localStorage.getItem('terminalLineEnding') || 'CRLF';
            let currentLineEnding = LINE_ENDING_MODES[savedLineEnding] || '\r\n';
            lineEndingSelect.value = savedLineEnding;
            
            // å³æ™‚æ›è¡Œæ¨¡å¼åˆ‡æ›è™•ç†
            lineEndingSelect.addEventListener('change', (e) => {
                const newMode = e.target.value;
                currentLineEnding = LINE_ENDING_MODES[newMode];
                localStorage.setItem('terminalLineEnding', newMode);
                console.log(`æ›è¡Œæ¨¡å¼å·²åˆ‡æ›ç‚º: ${newMode}`);
            });

           

           // è™•ç†çµ‚ç«¯æ©Ÿè¼¸å…¥ï¼Œä½¿ç”¨ç•¶å‰é¸æ“‡çš„æ›è¡Œæ¨¡å¼
            term.onData(async data => {
                if (!port) return;
                
                try {
                    if (data === '\r') {
                        // ä½¿ç”¨ç•¶å‰é¸æ“‡çš„æ›è¡Œæ¨¡å¼
                        await safeWrite(`R:${currentLineEnding}`);
                    } else {
                        await safeWrite('R:' + data);
                    }
                } catch (error) {
                    console.error('å¯«å…¥åºåˆ—åŸ æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    term.writeln('\r\néŒ¯èª¤ï¼šå¯«å…¥åºåˆ—åŸ å¤±æ•—');
                }
            });

            // åˆå§‹é€£ç·šç‹€æ…‹æª¢æŸ¥
            if (port) {
                updateTerminalButtonStates(true);
                // å¦‚æœå·²ç¶“æœ‰é€£æ¥ï¼Œè¨­å®š RS232 çš„é€Ÿç‡ä¸¦è¨­ç½®å…±äº« reader
                const baudRate = parseInt(document.getElementById('terminalBaudRate').value);
                safeWrite(`R:BAUD=${baudRate}\n`);
                setupSharedReader();
                term.writeln(`Terminal initialized (RS232 Rate: ${baudRate})`);
            } else {
                term.writeln('Terminal initialized (Not connected)');
            }

            document.getElementById('terminalConnect').addEventListener('click', async () => {
                if (!port) {
                    try {
                        const filters = [{
                            usbVendorId: 0x2341,
                            usbProductId: 0x8036
                        }];
                        
                        const baudRate = parseInt(document.getElementById('terminalBaudRate').value);
                        port = await navigator.serial.requestPort({ filters });
                        await port.open({ baudRate: 115200 });
                        
                        await safeWrite(`R:BAUD=${baudRate}\n`);
                        setupSharedReader();
                        term.writeln(`Connected to serial port (RS232 Rate: ${baudRate})`);
                        updateTerminalButtonStates(true);
                        addEventListeners();
                        enableMainControls();

                    } catch (error) {
                        console.error('Terminal connection error:', error);
                        term.writeln(`Error: ${error.message}`);
                        
                        if (error.name === 'NetworkError') {
                            alert('ç„¡æ³•é–‹å•Ÿåºåˆ—åŸ ï¼Œå¯èƒ½è¢«å…¶ä»–ç¨‹å¼ä½”ç”¨ä¸­ã€‚è«‹é—œé–‰å…¶ä»–ä½¿ç”¨æ­¤è£ç½®çš„ç¨‹å¼å¾Œå†è©¦ã€‚');
                        } else {
                            alert('é€£æ¥æ§åˆ¶å™¨æ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message);
                        }
                    }
                } else {
                    const baudRate = parseInt(document.getElementById('terminalBaudRate').value);
                    await safeWrite(`R:BAUD=${baudRate}\n`);
                    setupSharedReader();
                    term.writeln(`RS232 baud rate set to ${baudRate}`);
                }
            });

            // ä¸‹è¼‰è¨˜éŒ„æŒ‰éˆ•äº‹ä»¶
            document.getElementById('terminalDownload').addEventListener('click', () => {
                if (window.term) {
                    const content = getAllTerminalContent();
                    const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `terminal_log_${new Date().toISOString().replace(/[:.]/g, '-')}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            });


            // è¨­ç½®å…¶ä»–äº‹ä»¶ç›£è½å™¨
            setupTerminalEventListeners();
          

            // è¦–çª—å¤§å°æ”¹è®Šæ™‚èª¿æ•´çµ‚ç«¯æ©Ÿå¤§å°
            const resizeObserver = new ResizeObserver(() => {
                fitAddon.fit();
                window.term.refresh(0, window.term.rows - 1);
            });
            resizeObserver.observe(document.getElementById('terminal-container'));
        }



        // Serial è³‡æ–™è®€å–
        async function readLoop() {
            while (true) {
                try {
                    const { value, done } = await reader.read();
                    if (done) break;
                    term.write(new TextDecoder().decode(value));
                } catch (err) {
                    console.error('è®€å–è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤:', err);
                    break;
                }
            }
        }


        function enableMainControls() {
            connectControllerButton.disabled = true;
            disconnectControllerButton.disabled = false;
            ctrlAltDelButton.disabled = false;
            winButton.disabled = false;
            ctrlButton.disabled = false;
            altButton.disabled = false;
            fnButton.disabled = false;
            releaseAllModifiersButton.disabled = false;
            pasteTextButton.disabled = false;
        }

        
        function updateTerminalButtons() {
            if (document.getElementById('terminalConnect')) {
                document.getElementById('terminalConnect').disabled = false;
                document.getElementById('terminalResend').disabled = true;
                document.getElementById('terminalClear').disabled = true;
                document.getElementById('terminalBaudRate').disabled = false;
            }
        }


        function getAllTerminalContent() {
            const buffer = term.buffer.active;
            let content = '';
            for (let i = 0; i < buffer.length; i++) {
                const line = buffer.getLine(i);
                if (line) {
                    content += line.translateToString() + '\n';
                }
            }
            return content;
        }

        function setupSharedReader() {
            if (!port || !port.readable) return;

            const decoder = new TextDecoder();
            isReading = true; 

            async function readUntilClosed() {
                try {
                    sharedReader = port.readable.getReader();
                    while (isReading) {  
                        const { value, done } = await sharedReader.read();
                        if (done) break;3
                        if (window.term) {
                            window.term.write(decoder.decode(value));
                        }
                    }
                } catch (error) {
                    if (isReading) { 
                        console.error('è®€å–éŒ¯èª¤:', error);
                    }
                } finally {
                    if (sharedReader) {
                        try {
                            sharedReader.releaseLock();
                        } catch (error) {
                            console.error('é‡‹æ”¾ reader æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                        }
                        sharedReader = null;
                    }
                }
            }

            readUntilClosed().catch(error => {
                if (isReading) {
                    console.error('Reader loop error:', error);
                }
            });
        }


        connectControllerButton.addEventListener('click', connectController);
        disconnectControllerButton.addEventListener('click', disconnectController);

        // è¦–è¨Šä¾†æºåˆ‡æ›çš„ç›£è½å™¨
        videoSourceSelect.addEventListener('change', async () => {
            if (videoStream) {
                const selectedDeviceId = videoSourceSelect.value;
                const [width, height] = resolutionSelect.value.split('x').map(Number);

                try {
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: selectedDeviceId },
                            width: { exact: width },
                            height: { exact: height }
                        }
                    });

                    // åœæ­¢èˆŠçš„è¦–è¨Šä¸²æµ
                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = newStream;
                    video.srcObject = videoStream;

                    // å„²å­˜é¸æ“‡çš„è¦–è¨Šä¾†æº
                    localStorage.setItem('videoSourceId', selectedDeviceId);
                    
                } catch (error) {
                    console.error('åˆ‡æ›è¦–è¨Šä¾†æºå¤±æ•—:', error);
                    alert('åˆ‡æ›è¦–è¨Šä¾†æºå¤±æ•—ï¼Œè«‹é‡è©¦');
                }
            }
        });

        connectCaptureButton.addEventListener('click', startVideoStream);
        disconnectCaptureButton.addEventListener('click', stopVideoStream);

        // åœ¨é¸å–è§£æåº¦çš„ä¸‹æ‹‰é¸å–®åŠ å…¥äº‹ä»¶ç›£è½
        resolutionSelect.addEventListener('change', async () => {
            if (videoStream) {
                const [width, height] = resolutionSelect.value.split('x').map(Number);
                const selectedDeviceId = videoSourceSelect.value;

                try {
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: selectedDeviceId },
                            width: { exact: width },
                            height: { exact: height }
                        }
                    });

                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = newStream;
                    video.srcObject = videoStream;
                    
                    localStorage.setItem('resolution', resolutionSelect.value);
                } catch (error) {
                    console.error('åˆ‡æ›è§£æåº¦å¤±æ•—:', error);
                    alert('åˆ‡æ›è§£æåº¦å¤±æ•—ï¼Œè«‹é‡è©¦');
                }
            }
        });

        overlay.addEventListener('click', () => {
            overlay.focus();
        });

        overlay.addEventListener('keydown', (event) => {
            if (event.key === 'Tab') {
                event.preventDefault();
                overlay.focus();
            }
        });

        overlay.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });

        document.addEventListener('click', (event) => {
            if (isFnPopupVisible && 
                !fnButton.contains(event.target) && 
                !fnKeysPopup.contains(event.target)) {
                closeFnPopup();
            }
        });




  

        document.addEventListener('visibilitychange', handleVisibilityChange);
        window.addEventListener('blur', handleVisibilityChange);

        window.addEventListener('blur', closeFnPopup);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                closeFnPopup();
            }
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isPasting) {
                isPasting = false;
                isPausePasting = false;
                alert('åˆ‡æ›åˆ†é å°è‡´æ–‡å­—å‚³é€ä¸­æ–·');
            }
        });

        window.addEventListener('beforeunload', () => {
            releaseAllKeys();
        });

        window.addEventListener('beforeunload', () => {
            if (isPasting) {
                isPasting = false;
                isPausePasting = false;
            }
        });


        // åœ¨é é¢è¼‰å…¥æ™‚é¡¯ç¤ºæ–‡å­—
        window.addEventListener('load', () => {
            document.getElementById('noVideoText').style.display = 'block';
                    
            // çµ‚ç«¯æ©ŸæŒ‰éˆ•äº‹ä»¶
            document.getElementById('showTerminal').addEventListener('click', () => {
                    const terminalWindow = document.getElementById('terminalWindow');
                    terminalWindow.style.display = 'block';
                    
                    // åˆå§‹åŒ–çµ‚ç«¯æ©Ÿï¼ˆå¦‚æœé‚„æ²’æœ‰çš„è©±ï¼‰
                    if (!window.term) {
                        initializeTerminal();
                    }

                    // æª¢æŸ¥ç›®å‰é€£æ¥ç‹€æ…‹ï¼Œæ›´æ–°æŒ‰éˆ•
                    if (port) {
                        updateTerminalButtonStates(true);
                        // ç¢ºä¿é€Ÿç‡é¸é …å¯ç”¨
                        const terminalBaudRate = document.getElementById('terminalBaudRate');
                        if (terminalBaudRate) {
                            terminalBaudRate.disabled = false;
                        }
                    }
                });

                document.getElementById('minimizeTerminal').addEventListener('click', () => {
                    const terminalWindow = document.getElementById('terminalWindow');
                    const terminalContent = document.getElementById('terminalContent');
                    
                    if (terminalContent.style.display !== 'none') {
                        // æœ€å°åŒ–
                        terminalContent.style.display = 'none';
                        terminalWindow.style.height = '36px';  // åªä¿ç•™æ¨™é¡Œæ¬„é«˜åº¦
                        terminalWindow.style.resize = 'none';
                    } else {
                        // é‚„åŸ
                        terminalContent.style.display = 'flex';
                        terminalWindow.style.height = '400px';  // é‚„åŸé è¨­é«˜åº¦
                        terminalWindow.style.resize = 'both';
                    }
                });

                document.getElementById('closeTerminal').addEventListener('click', () => {
                    document.getElementById('terminalWindow').style.display = 'none';
                });

                // åˆå§‹åŒ–æ‹–æ›³åŠŸèƒ½
                makeWindowDraggable(
                    document.getElementById('terminalWindow'),
                    document.getElementById('terminalHeader')
                );

        });

        window.addEventListener('load', async () => {
            try {
                // ä¸»å‹•è«‹æ±‚è¦–è¨Šæ¬Šé™
                await navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        // å–å¾—æ¬Šé™å¾Œç«‹å³åœæ­¢ stream
                        stream.getTracks().forEach(track => track.stop());
                    });
            } catch (error) {
                console.error('è«‹æ±‚è¦–è¨Šæ¬Šé™å¤±æ•—:', error);
            }

            screenshotButton.addEventListener('click', takeScreenshot);
            startRecordButton.addEventListener('click', startRecording);
            stopRecordButton.addEventListener('click', stopRecording);

            await getVideoSources();

            overlay.tabIndex = 0;
            overlay.style.outline = 'none';

            overlay.addEventListener('keydown', checkControllerAndHighlight);
            overlay.addEventListener('mousedown', checkControllerAndHighlight);
            overlay.addEventListener('contextmenu', checkControllerAndHighlight);

            document.getElementById('videoContainer').addEventListener('keydown', (event) => {
                if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'a') {
                    event.preventDefault();
                }
            });

            video.addEventListener('keydown', (event) => {
                if ((event.ctrlKey || event.metaKey) && event.key.toLowerCase() === 'a') {
                    event.preventDefault();
                }
            });


            video.addEventListener('loadedmetadata', () => {
                console.log('è¦–è¨Šä¸­ç¹¼è³‡æ–™å·²è¼‰å…¥');
            });


            // ç›£è½æŒ‰éˆ•é»æ“Šäº‹ä»¶
            zoomInButton.addEventListener('click', zoomIn);
            zoomOutButton.addEventListener('click', zoomOut);

            // åˆå§‹åŒ–æŒ‰éˆ•ç‹€æ…‹
            applyZoom();
        });


    </script>


    <div id="terminalWindow" style="display: none;">
        <div id="terminalHeader">
            <div class="header-title">
                <span class="header-icon">ğŸ–¥ï¸</span>
                <span>åºåˆ—çµ‚ç«¯æ©Ÿ</span>
            </div>
            <div class="terminal-controls">
                <button id="minimizeTerminal">â”€</button>
                <button id="closeTerminal">Ã—</button>
            </div>
        </div>
        <div id="terminalContent">
            <div class="button-group">
                <span class="terminal-label">é€Ÿç‡</span>
                <select id="terminalBaudRate" title="å¤§éƒ¨ä»½è£ç½®é¸æ“‡ 9600 å³å¯ï¼ŒMikroTikeã€Juniper éƒ¨ä»½å‹è™Ÿç‚º 115200">
                    <option value="9600">9600</option>
                    <option value="19200">19200</option>
                    <option value="38400">38400</option>
                    <option value="57600">57600</option>
                    <option value="115200">115200</option>
                </select>
                <span class="terminal-label">æ›è¡Œ</span>
                <select id="lineEndingMode" title="å¤§éƒ¨ä»½è£ç½®é¸ç”¨ CRLF å³å¯ï¼Œåªæœ‰å°‘éƒ¨ä»½éœ€è¦å–®é¸ LF æˆ– CRï¼Œä¾‹å¦‚ Exterme èˆ‡ Juniper éƒ¨ä»½å‹è™Ÿ">
                    <option value="CRLF">CRLF (\r\n)</option>
                    <option value="CR">CR (\r)</option>
                    <option value="LF">LF (\n)</option>
                </select>
                <div class="separator"></div>
                <button id="terminalConnect">ğŸ”Œ é€£æ¥æ§åˆ¶å™¨</button>
                <button id="terminalClear" hidden>ğŸ§¹ æ¸…é™¤ç•«é¢</button>
                <button id="terminalDownload">â¬‡ï¸ ä¸‹è¼‰è¨˜éŒ„</button>
            </div>
            <div id="terminal-container"></div>
        </div>
    </div>

</body>
</html>
