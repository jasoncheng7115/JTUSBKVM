<!DOCTYPE html>
<!-- 

=========================================================================

JTUSBKVM - Web Console

Version: 1.0.0
Last Update: 2024-11-18

Author: Jason Cheng
E-mail: jason@jason.tools
GitHub: https://github.com/jasoncheng7115

License: GNU Affero General Public License v3.0
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
any later version.

=========================================================================

-->
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>JTUSBKVM - Jason Tools</title>
    <link rel="icon" type="image/png" sizes="512x512" href="logo-1.png">
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body, html {
            height: 100%;
            margin: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            background: #f0f0f0;
            padding: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
            min-height: 50px;
        }
        #titleContainer {
            display: flex;
            align-items: center;
            margin-bottom: 0;
        }
        #logo {
            height: 32px;
            margin-right: 10px;
        }
        #title {
            font-weight: bold;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 5px;
        }
        #rightControls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 5px;
        }
        #videoContainer {
            flex-grow: 1;
            position: relative;
            background: black;
            overflow: hidden; /* ÊîπÁÇ∫ hidden ‰ª•ÈÅøÂÖçÊç≤Ëª∏ */
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        video {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            transition: width 0.3s, height 0.3s;
            display: block;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            outline: none;
            cursor: crosshair;
        }
        select, button, input[type="text"] {
            height: 28px;
            line-height: 1;
            padding: 0 8px;
            margin: 0;
            vertical-align: middle;
            font-size: 12px;
            border: 1px solid #000;
            border-radius: 0;
            background-color: #e0e0e0;
            transition: background-color 0.3s, transform 0.1s, box-shadow 0.3s;
            cursor: pointer;
        }
        button:hover, input[type="text"]:hover {
            background-color: #b0b0b0;
        }
        @keyframes buttonHighlight {
            0% { background-color: #e0e0e0; }
            50% { background-color: #ff9999; }
            100% { background-color: #e0e0e0; }
        }
        .highlight-button {
            animation: buttonHighlight 1s ease-in-out 3;  /* ÈñÉÁàç 3 Ê¨° */
        }
        .tooltip {
            position: absolute;
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1000;
            animation: fadeInOut 3s ease-in-out;
            white-space: nowrap;
        }

        .tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 0 8px 8px 8px;
            border-style: solid;
            border-color: transparent transparent #333 transparent;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; }
            15% { opacity: 1; }
            85% { opacity: 1; }
            100% { opacity: 0; }
        }        
        .toggle-button:hover {
            background-color: #909090;
        }
        .toggle-button.active:hover {
            background-color: #555555;
        }
        button:active, .toggle-button:active, input[type="text"]:active {
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-button {
            background-color: #e0e0e0;
        }
        .toggle-button.active {
            background-color: #a0a0a0;
            color: white;
        }
        button:disabled, input[type="text"]:disabled {
            opacity: 0.5;
            border-color: #ccc;
            cursor: not-allowed;
        }
        .separator {
            height: 28px;
            margin: 0 5px;
            border-left: 1px solid #ccc;
        }
        .control-label {
            line-height: 28px;
            margin: 0;
            padding: 0 5px;
            font-weight: bold;
            font-size: 12px;
        }
        #fnKeysPopup {
            display: none;
            position: absolute;
            background: #f0f0f0;
            border: 1px solid #000;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }
        #fnKeysPopup button {
            padding: 5px 10px;
            margin: 0;
            width: 100%;
        }
        #noVideoText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            display: none;
        }
        #recordingTime {
            display: none;
            margin: 0 8px;
            font-family: monospace;
            font-size: 12px;
            line-height: 28px;
            color: #ff0000;
            font-weight: bold;
            min-width: 70px;
        }
        #video:not([src]):not([srcObject]) + #overlay + #noVideoText {
            display: block;
        }
        @media (max-width: 600px) {
            #controls {
                flex-direction: column;
                align-items: flex-start;
            }
            #rightControls {
                flex-direction: column;
                align-items: flex-start;
            }
            .separator {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="header">
        <div id="titleContainer">
            <img id="logo" src="logo-1.png" alt="Logo">
            <div id="title">JTUSBKVM</div>
        </div>
        <div id="controls">
            <span class="control-label">ÊéßÂà∂</span>
            <button id="connectController">üü¢ ÈÄ£Êé•</button>
            <button id="disconnectController" disabled>üî¥ ‰∏≠Êñ∑</button>
            <button id="ctrlAltDelButton" disabled>Ctrl+Alt+Delete</button>
            <button id="fnButton" class="toggle-button" disabled>Fn</button>
            <button id="winButton" class="toggle-button" disabled>Win</button>
            <button id="ctrlButton" class="toggle-button" disabled>Ctrl</button>
            <button id="altButton" class="toggle-button" disabled>Alt</button>
            <button id="releaseAllModifiers" class="toggle-button" disabled>üîÑ ÈáãÊîæ</button>
            <button id="pasteText" disabled>üìã Ë≤º‰∏ä</button>
            <div class="separator"></div>
            <div id="rightControls">
                <span class="control-label">Ë¶ñË®ä</span>
                <select id="videoSource"></select>
                <select id="resolution">
                    <option value="800x600">800x600</option>
                    <option value="1024x768">1024x768</option>
                    <option value="1280x720">1280x720</option>
                    <option value="1366x768">1366x768</option>
                    <option value="1920x1080">1920x1080</option>
                </select>
                <button id="connectCapture">‚ñ∂Ô∏è ÈÄ£Êé•</button>
                <button id="disconnectCapture" disabled>‚èπÔ∏è ‰∏≠Êñ∑</button>
                <button id="screenshot" disabled>üñºÔ∏è Êì∑Âúñ</button>
                <button id="startRecord" disabled>üî¥ ÈåÑÂΩ±</button>
                <span id="recordingTime" style="display: none;">00:00:00</span>
                <button id="stopRecord" disabled>‚¨õ ÂÅúÊ≠¢</button>
            </div>
        </div>
    </div>

    <div id="fnKeysPopup">
        <button class="fn-key" data-key="F1">F1</button>
        <button class="fn-key" data-key="F2">F2</button>
        <button class="fn-key" data-key="F3">F3</button>
        <button class="fn-key" data-key="F4">F4</button>
        <button class="fn-key" data-key="F5">F5</button>
        <button class="fn-key" data-key="F6">F6</button>
        <button class="fn-key" data-key="F7">F7</button>
        <button class="fn-key" data-key="F8">F8</button>
        <button class="fn-key" data-key="F9">F9</button>
        <button class="fn-key" data-key="F10">F10</button>
        <button class="fn-key" data-key="F11">F11</button>
        <button class="fn-key" data-key="F12">F12</button>
    </div>

    <div id="pasteDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
    background: white; padding: 20px; border: 1px solid #000; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; 
    min-width: 500px; max-width: 80%;">
        <div style="margin-bottom: 10px; font-weight: bold;">ÊñáÂ≠óÂÇ≥ÈÄÅÂ∑•ÂÖ∑</div>
        <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-left: 4px solid #004085; font-size: 14px;">
            <p style="margin: 0 0 8px 0;">Ê≠§Â∑•ÂÖ∑ÊúÉÊ®°Êì¨ÈçµÁõ§Âú®ÁõÆÊ®ôÈõªËÖ¶‰∏äÈÄêÂ≠óËº∏ÂÖ•ÊñáÂ≠ó„ÄÇ</p>
            <p style="margin: 0 0 8px 0;">ÊîØÊè¥ÂÖßÂÆπÔºö</p>
            <ul style="margin: 0 0 8px 20px; padding: 0;">
                <li>Ëã±ÊñáÂ≠óÊØçÔºàÂ§ßÂ∞èÂØ´Ôºâ</li>
                <li>Êï∏Â≠ó</li>
                <li>Ê®ôÈªûÁ¨¶Ëôü</li>
                <li>Á©∫Ê†ºÂíåÊèõË°å</li>
            </ul>
            <p style="margin: 0; color: #dc3545;">Ê≥®ÊÑèÔºö‰∏çÊîØÊè¥‰∏≠Êñá„ÄÅÊó•Êñá„ÄÅÈüìÊñáÁ≠âÈùûËã±ÊñáÂ≠óÂÖÉ</p>
        </div>
        <div style="margin-bottom: 10px;">Ë´ãË≤º‰∏äË¶ÅÂÇ≥ÈÄÅÁöÑÊñáÂ≠óÔºö</div>
        <textarea id="pasteArea" rows="10" cols="50" style="width: 100%; margin-bottom: 10px; padding: 8px;"></textarea>
        <div id="pasteProgress" style="display: none; margin-bottom: 10px; padding: 8px; background: #e9ecef;">
            ÈÄ≤Â∫¶Ôºö<span id="pasteStatus">0</span>/<span id="pasteTotal">0</span> 
            (<span id="pastePercent">0</span>%)
        </div>
        <div style="display: flex; gap: 10px;">
            <button id="startPaste" style="padding: 5px 15px;">ÈñãÂßãÂÇ≥ÈÄÅ</button>
            <button id="pausePaste" style="padding: 5px 15px;">Êö´ÂÅú</button>
            <button id="cancelPaste" style="padding: 5px 15px;">ÂèñÊ∂à</button>
        </div>
    </div>

    <div id="videoContainer">
        <video id="video" autoplay muted></video>
        <div id="overlay" tabindex="0"></div>
        <div id="noVideoText">Â∞öÊú™ÈÄ£Êé•Ë¶ñË®ä‰æÜÊ∫ê</div>   
    </div>

    <script>
        const connectControllerButton = document.getElementById('connectController');
        const disconnectControllerButton = document.getElementById('disconnectController');
        const connectCaptureButton = document.getElementById('connectCapture');
        const disconnectCaptureButton = document.getElementById('disconnectCapture');
        const video = document.getElementById('video');
        const videoSourceSelect = document.getElementById('videoSource');
        const resolutionSelect = document.getElementById('resolution');
        const overlay = document.getElementById('overlay');
        const ctrlAltDelButton = document.getElementById('ctrlAltDelButton');
        const winButton = document.getElementById('winButton');
        const ctrlButton = document.getElementById('ctrlButton');
        const altButton = document.getElementById('altButton');
        const fnButton = document.getElementById('fnButton');
        const releaseAllModifiersButton = document.getElementById('releaseAllModifiers');
        const fnKeysPopup = document.getElementById('fnKeysPopup');
        const screenshotButton = document.getElementById('screenshot');
        const startRecordButton = document.getElementById('startRecord');
        const stopRecordButton = document.getElementById('stopRecord');
        const recordingTimeDisplay = document.getElementById('recordingTime');
        const pressedModifiers = new Set();
        const modifierKeys = {
            ControlLeft: 'Control',
            ControlRight: 'Control',
            AltLeft: 'Alt',
            AltRight: 'Alt',
            MetaLeft: 'Meta',
            MetaRight: 'Meta',
            ShiftLeft: 'Shift',
            ShiftRight: 'Shift'
        };
        const pressedKeys = new Set();   
        const pasteTextButton = document.getElementById('pasteText');
        const pasteDialog = document.getElementById('pasteDialog');
        const pasteArea = document.getElementById('pasteArea');
        const startPasteButton = document.getElementById('startPaste');
        const pausePasteButton = document.getElementById('pausePaste');
        const cancelPasteButton = document.getElementById('cancelPaste');
        const pasteProgress = document.getElementById('pasteProgress');
        const pasteStatus = document.getElementById('pasteStatus');
        const pasteTotal = document.getElementById('pasteTotal');
        const pastePercent = document.getElementById('pastePercent');
        const keyboardMap = {
            'a': 'KeyA', 'b': 'KeyB', 'c': 'KeyC', 'd': 'KeyD', 'e': 'KeyE',
            'f': 'KeyF', 'g': 'KeyG', 'h': 'KeyH', 'i': 'KeyI', 'j': 'KeyJ',
            'k': 'KeyK', 'l': 'KeyL', 'm': 'KeyM', 'n': 'KeyN', 'o': 'KeyO',
            'p': 'KeyP', 'q': 'KeyQ', 'r': 'KeyR', 's': 'KeyS', 't': 'KeyT',
            'u': 'KeyU', 'v': 'KeyV', 'w': 'KeyW', 'x': 'KeyX', 'y': 'KeyY',
            'z': 'KeyZ',
            '1': 'Digit1', '2': 'Digit2', '3': 'Digit3', '4': 'Digit4', '5': 'Digit5',
            '6': 'Digit6', '7': 'Digit7', '8': 'Digit8', '9': 'Digit9', '0': 'Digit0',
            '-': 'Minus', '=': 'Equal',
            '[': 'BracketLeft', ']': 'BracketRight',
            '\\': 'Backslash',
            ';': 'Semicolon', "'": 'Quote',
            ',': 'Comma', '.': 'Period',
            '/': 'Slash', '`': 'Backquote',
            ' ': 'Space'
        };
        const needsShift = new Set([
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
            '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+',
            '{', '}', '|', ':', '"', '<', '>', '?'
        ]);
        const WHEEL_DELAY = 50; // Âª∂ÈÅ≤ 50ms

        let videoStream;
        let port;
        let writer;
        let isPasting = false;
        let isPausePasting = false;
        let currentPasteIndex = 0;
        let textToSend = '';
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingTimer = null;
        let recordingStartTime = null;
        let keyEventListener = null;
        let mouseMoveListener = null;
        let mouseClickListener = null; 
        let lastMouseX = null;
        let lastMouseY = null;
        let lastConsoleLogTime = 0;
        let isFnPopupVisible = false;
        let lastWheelTime = 0;

        async function sendCtrlAltDel() {
            if (writer) {
                try {
                    // Áõ¥Êé•ÂÇ≥ÈÄÅÁâπÂÆöÁöÑ Ctrl+Alt+Del ÂëΩ‰ª§
                    await writer.write(new TextEncoder().encode('CTRL_ALT_DEL\n'));
                    console.log('Â∑≤ÂÇ≥ÈÄÅ Ctrl+Alt+Delete ÂëΩ‰ª§');
                } catch (error) {
                    console.error('ÂÇ≥ÈÄÅ Ctrl+Alt+Delete ÊôÇÁôºÁîüÈåØË™§:', error);
                }
            }
        }

        // Êì∑ÂúñÂäüËÉΩ
        async function takeScreenshot() {
            if (video.srcObject) {
                try {
                    // Âª∫Á´ã canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    // Âú® canvas ‰∏äÁπ™Ë£ΩÁõÆÂâçË¶ñË®äÁï´Èù¢
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // ËΩâÊèõÁÇ∫ blob
                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/png');
                    });
                    
                    // Âª∫Á´ã‰∏ãËºâÈÄ£Áµê
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `screenshot_${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('Êì∑ÂúñÊôÇÁôºÁîüÈåØË™§:', error);
                    alert('Êì∑ÂúñÂ§±ÊïóÔºåË´ãÈáçË©¶');
                }
            }
        }


        // Ê™¢Êü•ÊòØÂê¶ÂåÖÂê´‰∏≠Êó•ÈüìÊñáÂ≠ó
        function containsCJK(text) {
            // Unicode ÁØÑÂúçÔºö
            // ‰∏≠ÊñáÔºö\u4e00-\u9fff
            // Êó•ÊñáÂÅáÂêçÔºö\u3040-\u309f\u30a0-\u30ff
            // ÈüìÊñáÔºö\uac00-\ud7af\u1100-\u11ff
            const cjkRegex = /[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af\u1100-\u11ff]/;
            return cjkRegex.test(text);
        }


        // ÈñãÂßãÈåÑÂΩ±
        function startRecording() {
            try {
                recordedChunks = [];
                const options = { 
                    mimeType: 'video/mp4;codecs=h264,aac'  // ÂòóË©¶‰ΩøÁî® MP4
                };

                // Â¶ÇÊûúÁÄèË¶ΩÂô®‰∏çÊîØÊè¥ MP4 ÈåÑË£ΩÔºåÂõûÂà∞ WebM
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    console.log('MP4 Ê†ºÂºè‰∏çÊîØÊè¥Ôºå‰ΩøÁî® WebM');
                    options.mimeType = 'video/webm;codecs=vp9';
                }

                mediaRecorder = new MediaRecorder(video.srcObject, options);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = saveRecording;
                
                mediaRecorder.start();
                startRecordButton.disabled = true;
                stopRecordButton.disabled = false;
                console.log('ÈñãÂßãÈåÑÂΩ±');
            } catch (error) {
                console.error('ÈñãÂßãÈåÑÂΩ±ÊôÇÁôºÁîüÈåØË™§:', error);
                alert('ÈñãÂßãÈåÑÂΩ±Â§±ÊïóÔºåË´ãÈáçË©¶');
            }
        }


        function highlightConnectController() {
            if (!connectControllerButton.classList.contains('highlight-button')) {
                
                // Â¢ûÂä†ÈñÉÁàçÊïàÊûú
                connectControllerButton.classList.add('highlight-button');
                
                // Âª∫Á´ãÊèêÁ§∫Ê°Ü
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.textContent = 'Ë´ãÂÖàÈÄ£Êé•ÊéßÂà∂Âô®ÊâçËÉΩ‰ΩøÁî®ÈçµÁõ§ÊªëÈº†ÂäüËÉΩÔºÅ';
                
                // Ë®àÁÆó‰ΩçÁΩÆ
                const buttonRect = connectControllerButton.getBoundingClientRect();
                tooltip.style.left = `${buttonRect.left + (buttonRect.width / 2)}px`;
                tooltip.style.top = `${buttonRect.bottom + 10}px`;
                tooltip.style.transform = 'translateX(-50%)';
                
                // Âä†ÂÖ•Âà∞ body ‰∏≠
                document.body.appendChild(tooltip);
                
                // Ë®≠ÂÆöÊôÇÂô®ÁßªÈô§ÊïàÊûú
                setTimeout(() => {
                    connectControllerButton.classList.remove('highlight-button');
                    document.body.removeChild(tooltip);
                }, 3000);
            }
        }

        function checkControllerAndHighlight(event) {
            if (!port && video.srcObject) {  // Â¶ÇÊûúÊ≤íÊúâÈÄ£Êé•ÊéßÂà∂Âô®‰ΩÜÊúâË¶ñË®ä
                event.preventDefault();  // ÈòªÊ≠¢È†êË®≠Ë°åÁÇ∫
                highlightConnectController();
            }
        }

        function updateRecordingTime() {
            const elapsedTime = Date.now() - recordingStartTime;
            const totalSeconds = Math.floor(elapsedTime / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            recordingTimeDisplay.textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // ÂÅúÊ≠¢ÈåÑÂΩ±
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                startRecordButton.disabled = false;
                stopRecordButton.disabled = true;
                // ÂÅúÊ≠¢Ë®àÊôÇÂô®ÊúÉÂú® mediaRecorder.onstop ‰∏≠ËôïÁêÜ
                console.log('ÂÅúÊ≠¢ÈåÑÂΩ±');
            }
        }

        // ÂÑ≤Â≠òÈåÑÂΩ±
        function saveRecording() {
            try {
                const mimeType = mediaRecorder.mimeType;
                const blob = new Blob(recordedChunks, { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // Âà§Êñ∑Ê™îÊ°àÊ†ºÂºè
                const fileExt = mimeType.includes('mp4') ? 'mp4' : 'webm';
                a.download = `recording_${new Date().toISOString().replace(/[:.]/g, '-')}.${fileExt}`;
                
                if (fileExt === 'webm') {
                    alert('Áî±ÊñºÁÄèË¶ΩÂô®ÈôêÂà∂ÔºåÂΩ±ÁâáÂ∑≤ÂÑ≤Â≠òÁÇ∫ WebM Ê†ºÂºè„ÄÇÂ¶ÇÈúÄ MP4 Ê†ºÂºèÔºåË´ã‰ΩøÁî®ÂΩ±ÁâáËΩâÊ™îËªüÈ´îÈÄ≤Ë°åËΩâÊèõ„ÄÇ');
                }
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                recordedChunks = [];
            } catch (error) {
                console.error('ÂÑ≤Â≠òÈåÑÂΩ±ÊôÇÁôºÁîüÈåØË™§:', error);
                alert('ÂÑ≤Â≠òÈåÑÂΩ±Â§±ÊïóÔºåË´ãÈáçË©¶');
            }
        }

        function stopVideoStream() {
            if (videoStream) {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    stopRecording();
                    clearInterval(recordingTimer);
                    recordingTimeDisplay.style.display = 'none';
                }
                videoStream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                videoStream = null;
                document.getElementById('noVideoText').style.display = 'block';
            }
            connectCaptureButton.disabled = false;
            disconnectCaptureButton.disabled = true;
            screenshotButton.disabled = true;       
            startRecordButton.disabled = true;      
            stopRecordButton.disabled = true;       
            pasteTextButton.disabled = true;
        }

        async function getVideoSources() {
            try {
                // ÂÖàË´ãÊ±ÇÊ¨äÈôê
                await navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        // ÂèñÂæóÊ¨äÈôêÂæåÁ´ãÂç≥ÂÅúÊ≠¢stream
                        stream.getTracks().forEach(track => track.stop());
                    });
                    
                // ‰πãÂæåÂÜçÂàóËàâË®≠ÂÇô
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');

                videoSourceSelect.innerHTML = videoDevices.map(device => {
                    let label = device.label || 'Ë¶ñË®ä‰æÜÊ∫ê';
                    label = label.replace(/\(.*?\)/g, '').trim();
                    return `<option value="${device.deviceId}">${label}</option>`;
                }).join('');

                const savedVideoSource = localStorage.getItem('videoSourceId');
                const savedResolution = localStorage.getItem('resolution');

                if (savedVideoSource && videoDevices.some(device => device.deviceId === savedVideoSource)) {
                    videoSourceSelect.value = savedVideoSource;
                }

                if (savedResolution) {
                    resolutionSelect.value = savedResolution;
                }
            } catch (error) {
                console.error('ÂèñÂæóË¶ñË®ä‰æÜÊ∫êÊôÇÁôºÁîüÈåØË™§:', error);
                alert('Ë´ãÂÖÅË®±Ë¶ñË®äÊ¨äÈôê‰ª•‰ΩøÁî®Ê≠§ÂäüËÉΩ');
            }
        }

        async function startVideoStream() {
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            const selectedDeviceId = videoSourceSelect.value;
            const [width, height] = resolutionSelect.value.split('x').map(Number);

            const constraints = {
                video: {
                    deviceId: { exact: selectedDeviceId },
                    width: { exact: width },
                    height: { exact: height }
                    }
                };

                try {
                    videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                    video.srcObject = videoStream;
                    document.getElementById('noVideoText').style.display = 'none'; 

                    video.onloadedmetadata = () => {
                        connectCaptureButton.disabled = true;
                        disconnectCaptureButton.disabled = false;
                        screenshotButton.disabled = false;      
                        startRecordButton.disabled = false;     
                        stopRecordButton.disabled = true;       

                        localStorage.setItem('videoSourceId', selectedDeviceId);
                        localStorage.setItem('resolution', resolutionSelect.value);

                    };
                } catch (error) {
                    console.error('ÈñãÂßãË¶ñË®ä‰∏≤ÊµÅÊôÇÁôºÁîüÈåØË™§:', error);
                    // È°ØÁ§∫Êõ¥ÂèãÂñÑÁöÑÈåØË™§Ë®äÊÅØ
                    if (error.name === 'NotAllowedError') {
                        alert('Ë´ãÂÖÅË®±Ë¶ñË®äÊ¨äÈôê‰ª•‰ΩøÁî®Ê≠§ÂäüËÉΩ');
                    } else if (error.name === 'NotFoundError') {
                        alert('Êâæ‰∏çÂà∞ÊåáÂÆöÁöÑË¶ñË®äË£ùÁΩÆ');
                    } else if (error.name === 'NotReadableError') {
                        alert('ÁÑ°Ê≥ïÂ≠òÂèñË¶ñË®äË£ùÁΩÆÔºåÂèØËÉΩË¢´ÂÖ∂‰ªñÁ®ãÂºè‰ΩîÁî®');
                    } else {
                        alert('Ë¶ñË®äÂïüÂãïÂ§±ÊïóÔºö' + error.message);
                    }
                }
            }
            
    
        async function connectController() {
            
            // Ê™¢Êü•ÊòØÂê¶Â∑≤ÈÄ£Êé•Ë¶ñË®ä
            if (!videoStream) {
                // ÂèñÊ∂àÂéüÊú¨ÁöÑÈÄ£Êé•Âãï‰Ωú
                highlightConnectCapture();
                return;
            }
            
            if ('serial' in navigator) {
                try {
                    port = await navigator.serial.requestPort();
                    await port.open({ baudRate: 115200 });
    
                    connectControllerButton.disabled = true;
                    disconnectControllerButton.disabled = false;
    
                    writer = port.writable.getWriter();
    
                    addEventListeners();
                    overlay.focus();
    
                    ctrlAltDelButton.disabled = false;
                    winButton.disabled = false;
                    ctrlButton.disabled = false;
                    altButton.disabled = false;
                    fnButton.disabled = false;
                    releaseAllModifiersButton.disabled = false;
                    pasteTextButton.disabled = false;  
    
                } catch (error) {
                    console.error('ÈÄ£Êé•ÊéßÂà∂Âô®ÊôÇÁôºÁîüÈåØË™§:', error);
                }
            } else {
                alert('ÊÇ®ÁöÑÁÄèË¶ΩÂô®‰∏çÊîØÊè¥ Web Serial API');
            }
        }
    
        async function disconnectController() {
            if (writer) {
                try {
                    // ‰∏≠Êñ∑ÂâçÂÇ≥ÈÄÅ RELEASE_ALL
                    await writer.write(new TextEncoder().encode('RELEASE_ALL\n'));
                } catch (error) {
                    console.error('ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§ÊôÇÁôºÁîüÈåØË™§:', error);
                }
                writer.releaseLock();
                writer = null;
            }
    
            if (port) {
                await port.close();
                port = null;
            }
    
            connectControllerButton.disabled = false;
            disconnectControllerButton.disabled = true;
    
            removeEventListeners();
            await resetButtonStates();
    
            ctrlAltDelButton.disabled = true;
            winButton.disabled = true;
            ctrlButton.disabled = true;
            altButton.disabled = true;
            fnButton.disabled = true;
            releaseAllModifiersButton.disabled = true;
            pasteTextButton.disabled = true;
    
            closeFnPopup();
            lastMouseX = null;
            lastMouseY = null;
        }
    
        function addEventListeners() {
            keyEventListener = (event) => sendKeyToArduino(event);
            overlay.addEventListener('keydown', keyEventListener);
            overlay.addEventListener('keyup', keyEventListener);
    
            mouseMoveListener = (event) => sendMouseMovementToArduino(event);
            overlay.addEventListener('mousemove', mouseMoveListener);
    
            mouseClickListener = (event) => sendMouseClickToArduino(event);
            overlay.addEventListener('mousedown', mouseClickListener);
            overlay.addEventListener('mouseup', mouseClickListener);
            
            overlay.addEventListener('wheel', handleMouseWheel);

           
            ctrlAltDelButton.addEventListener('click', sendCtrlAltDel);
            winButton.addEventListener('click', toggleWinKey);
            ctrlButton.addEventListener('click', toggleCtrlKey);
            altButton.addEventListener('click', toggleAltKey);
            fnButton.addEventListener('click', toggleFnKeys);
            releaseAllModifiersButton.addEventListener('click', releaseAllModifiers);
    
            pasteTextButton.addEventListener('click', () => {
                pasteDialog.style.display = 'block';
                pasteArea.value = '';
                pasteProgress.style.display = 'none';
                isPasting = false;
                isPausePasting = false;
            });

            cancelPasteButton.addEventListener('click', () => {
                pasteDialog.style.display = 'none';
                if (isPasting) {
                    isPasting = false;
                    isPausePasting = false;
                }
            });

            pausePasteButton.addEventListener('click', () => {
                if (isPasting) {
                    isPausePasting = !isPausePasting;
                    pausePasteButton.textContent = isPausePasting ? 'ÁπºÁ∫å' : 'Êö´ÂÅú';
                }
            });

            startPasteButton.addEventListener('click', async () => {
                if (!writer) {
                    alert('Ë´ãÂÖàÈÄ£Êé•ÊéßÂà∂Âô®');
                    return;
                }

                textToSend = pasteArea.value;
                if (!textToSend) {
                    alert('Ë´ãËº∏ÂÖ•Ë¶ÅÂÇ≥ÈÄÅÁöÑÊñáÂ≠ó');
                    return;
                }

                // Ê™¢Êü•ÊòØÂê¶ÂåÖÂê´‰∏≠Êó•ÈüìÊñáÂ≠ó
                if (containsCJK(textToSend)) {
                    if (!confirm('Ê™¢Ê∏¨Âà∞ÊñáÂ≠ó‰∏≠ÂåÖÂê´‰∏≠Êñá„ÄÅÊó•ÊñáÊàñÈüìÊñáÂ≠óÂÖÉÔºåÈÄô‰∫õÂ≠óÂÖÉÂ∞áÁÑ°Ê≥ïÊ≠£Á¢∫ÂÇ≥ÈÄÅ„ÄÇ\n\nË¶ÅÁπºÁ∫åÂÇ≥ÈÄÅÂóéÔºüÔºà‰∏çÊîØÊè¥ÁöÑÂ≠óÂÖÉÂ∞áË¢´Ë∑≥ÈÅéÔºâ')) {
                        return;
                    }
                }

                if (!isPasting) {
                    isPasting = true;
                    currentPasteIndex = 0;
                    pasteProgress.style.display = 'block';
                    pasteTotal.textContent = textToSend.length;
                    startPasteButton.disabled = true;
                    pasteArea.disabled = true;

                    sendTextByChar();
                }
            });

            overlay.addEventListener('mouseleave', handleMouseLeave);
    
            document.querySelectorAll('.fn-key').forEach(button => {
                button.addEventListener('click', () => {
                    handleFnKeyPress(button.dataset.key);
                });
            });

        }

        // Ë¶ñË®äÈÄ£Êé•ÊåâÈàïÁöÑÊèêÁ§∫ÂáΩÊï∏
        function highlightConnectCapture() {
            if (!connectCaptureButton.classList.contains('highlight-button')) {
                // Â¢ûÂä†ÈñÉÁàçÊïàÊûú
                connectCaptureButton.classList.add('highlight-button');
                
                // Âª∫Á´ãÊèêÁ§∫Ê°Ü
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.textContent = 'Ë´ãÂÖàÈÄ£Êé•Ë¶ñË®äÁï´Èù¢ÔºåÂÜçÈÄ£Êé•ÊéßÂà∂Âô®ÔºÅ';
                
                // Ë®àÁÆó‰ΩçÁΩÆ
                const buttonRect = connectCaptureButton.getBoundingClientRect();
                tooltip.style.left = `${buttonRect.left + (buttonRect.width / 2)}px`;
                tooltip.style.top = `${buttonRect.bottom + 10}px`;
                tooltip.style.transform = 'translateX(-50%)';
                
                // Âä†ÂÖ•Âà∞ body ‰∏≠
                document.body.appendChild(tooltip);
                
                // Ë®≠ÂÆöÊôÇÂô®ÁßªÈô§ÊïàÊûú
                setTimeout(() => {
                    connectCaptureButton.classList.remove('highlight-button');
                    document.body.removeChild(tooltip);
                }, 3000);
            }
        }


        function removeEventListeners() {
            if (keyEventListener) {
                overlay.removeEventListener('keydown', keyEventListener);
                overlay.removeEventListener('keyup', keyEventListener);
                keyEventListener = null;
            }
    
            if (mouseMoveListener) {
                overlay.removeEventListener('mousemove', mouseMoveListener);
                mouseMoveListener = null;
            }
    
            if (mouseClickListener) {
                overlay.removeEventListener('mousedown', mouseClickListener);
                overlay.removeEventListener('mouseup', mouseClickListener);
                mouseClickListener = null;
            }
    
            overlay.removeEventListener('wheel', handleMouseWheel);

            ctrlAltDelButton.removeEventListener('click', sendCtrlAltDel);
            winButton.removeEventListener('click', toggleWinKey);
            ctrlButton.removeEventListener('click', toggleCtrlKey);
            altButton.removeEventListener('click', toggleAltKey);
            fnButton.removeEventListener('click', toggleFnKeys);
            releaseAllModifiersButton.removeEventListener('click', releaseAllModifiers);
       
            overlay.removeEventListener('mouseleave', handleMouseLeave);
    
            document.querySelectorAll('.fn-key').forEach(button => {
                button.removeEventListener('click', () => {
                    handleFnKeyPress(button.dataset.key);
                });
            });
        }

        async function sendTextByChar() {
            if (!isPasting || !writer) {
                resetPasteStatus();
                return;
            }

            if (isPausePasting) {
                setTimeout(sendTextByChar, 100);
                return;
            }

            if (currentPasteIndex >= textToSend.length) {
                resetPasteStatus();
                pasteDialog.style.display = 'none';
                return;
            }

            try {
                const char = textToSend[currentPasteIndex];
                const DELAY = 15; // Âª∂ÈÅ≤ÊôÇÈñì

                async function sendKeyStrokes(keystrokes) {
                    for (const stroke of keystrokes) {
                        await writer.write(new TextEncoder().encode(stroke + '\n'));
                        await new Promise(resolve => setTimeout(resolve, DELAY));
                    }
                }

                function getKeyStrokes(char) {
                    switch (char) {
                        // Êï∏Â≠ó‰∏äÊñπÁöÑÁ¨¶Ëôü
                        case '!': return ['MOD_DOWN Shift', 'KEY_DOWN Digit1', 'KEY_UP Digit1', 'MOD_UP Shift'];
                        case '@': return ['MOD_DOWN Shift', 'KEY_DOWN Digit2', 'KEY_UP Digit2', 'MOD_UP Shift'];
                        case '#': return ['MOD_DOWN Shift', 'KEY_DOWN Digit3', 'KEY_UP Digit3', 'MOD_UP Shift'];
                        case '$': return ['MOD_DOWN Shift', 'KEY_DOWN Digit4', 'KEY_UP Digit4', 'MOD_UP Shift'];
                        case '%': return ['MOD_DOWN Shift', 'KEY_DOWN Digit5', 'KEY_UP Digit5', 'MOD_UP Shift'];
                        case '^': return ['MOD_DOWN Shift', 'KEY_DOWN Digit6', 'KEY_UP Digit6', 'MOD_UP Shift'];
                        case '&': return ['MOD_DOWN Shift', 'KEY_DOWN Digit7', 'KEY_UP Digit7', 'MOD_UP Shift'];
                        case '*': return ['MOD_DOWN Shift', 'KEY_DOWN Digit8', 'KEY_UP Digit8', 'MOD_UP Shift'];
                        case '(': return ['MOD_DOWN Shift', 'KEY_DOWN Digit9', 'KEY_UP Digit9', 'MOD_UP Shift'];
                        case ')': return ['MOD_DOWN Shift', 'KEY_DOWN Digit0', 'KEY_UP Digit0', 'MOD_UP Shift'];

                        // Á¨¶ËôüÈçµ
                        case '_': return ['MOD_DOWN Shift', 'KEY_DOWN Minus', 'KEY_UP Minus', 'MOD_UP Shift'];
                        case '+': return ['MOD_DOWN Shift', 'KEY_DOWN Equal', 'KEY_UP Equal', 'MOD_UP Shift'];
                        case '{': return ['MOD_DOWN Shift', 'KEY_DOWN BracketLeft', 'KEY_UP BracketLeft', 'MOD_UP Shift'];
                        case '}': return ['MOD_DOWN Shift', 'KEY_DOWN BracketRight', 'KEY_UP BracketRight', 'MOD_UP Shift'];
                        case '|': return ['MOD_DOWN Shift', 'KEY_DOWN Backslash', 'KEY_UP Backslash', 'MOD_UP Shift'];
                        case ':': return ['MOD_DOWN Shift', 'KEY_DOWN Semicolon', 'KEY_UP Semicolon', 'MOD_UP Shift'];
                        case '"': return ['MOD_DOWN Shift', 'KEY_DOWN Quote', 'KEY_UP Quote', 'MOD_UP Shift'];
                        case '<': return ['MOD_DOWN Shift', 'KEY_DOWN Comma', 'KEY_UP Comma', 'MOD_UP Shift'];
                        case '>': return ['MOD_DOWN Shift', 'KEY_DOWN Period', 'KEY_UP Period', 'MOD_UP Shift'];
                        case '?': return ['MOD_DOWN Shift', 'KEY_DOWN Slash', 'KEY_UP Slash', 'MOD_UP Shift'];
                        case '~': return ['MOD_DOWN Shift', 'KEY_DOWN Backquote', 'KEY_UP Backquote', 'MOD_UP Shift'];

                        // ÊèõË°åÂíå‰∏ÄËà¨ÊåâÈçµ
                        case '\n':
                        case '\r':
                            return ['KEY_DOWN Enter', 'KEY_UP Enter'];

                        default:
                            if (char >= 'A' && char <= 'Z') {
                                return [
                                    'MOD_DOWN Shift',
                                    `KEY_DOWN Key${char}`,
                                    `KEY_UP Key${char}`,
                                    'MOD_UP Shift'
                                ];
                            } else {
                                const keyCode = keyboardMap[char];
                                return keyCode ? [`KEY_DOWN ${keyCode}`, `KEY_UP ${keyCode}`] : [];
                            }
                    }
                }

                const keyStrokes = getKeyStrokes(char);
                if (keyStrokes.length > 0) {
                    await sendKeyStrokes(keyStrokes);
                }

                currentPasteIndex++;
                pasteStatus.textContent = currentPasteIndex;
                pastePercent.textContent = Math.round((currentPasteIndex / textToSend.length) * 100);

                setTimeout(sendTextByChar, DELAY);

            } catch (error) {
                console.error('ÂÇ≥ÈÄÅÊñáÂ≠óÊôÇÁôºÁîüÈåØË™§:', error);
                resetPasteStatus();
                alert('ÂÇ≥ÈÄÅÊñáÂ≠óÊôÇÁôºÁîüÈåØË™§ÔºåË´ãÈáçË©¶');
            }
        }
   

        async function handleMouseWheel(event) {
            if (writer) {
                const now = Date.now();
                if (now - lastWheelTime < WHEEL_DELAY) {
                    return; // Â¶ÇÊûúË∑ùÈõ¢‰∏äÊ¨°Êç≤ÂãïÊôÇÈñìÂ§™ËøëÔºåÂøΩÁï•
                }
                lastWheelTime = now;

                event.preventDefault();
                const scrollAmount = -Math.sign(event.deltaY);
                
                try {
                    const data = `MOUSE_SCROLL ${scrollAmount}\n`;
                    await writer.write(new TextEncoder().encode(data));
                } catch (error) {
                    console.error('ÂÇ≥ÈÄÅÊªëÈº†ÊªæËº™‰∫ã‰ª∂ÊôÇÁôºÁîüÈåØË™§:', error);
                }
            }
        }

        async function sendKeyToArduino(event) {
            if (writer) {
                overlay.focus();
    
                const type = event.type === 'keydown' ? 'KEY_DOWN' : 'KEY_UP';
                const key = event.code;
    
                if (type === 'KEY_DOWN') {
                    pressedKeys.add(key);
                } else {
                    pressedKeys.delete(key);
                }
    
                if (modifierKeys[key]) {
                    const modifier = modifierKeys[key];
                    const modType = event.type === 'keydown' ? 'MOD_DOWN' : 'MOD_UP';
                    const data = `${modType} ${modifier}\n`;
    
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log(`Â∑≤ÂÇ≥ÈÄÅ‰øÆÈ£æÈçµÔºö${data.trim()}`);
                    } catch (error) {
                        console.error('ÂÇ≥ÈÄÅ‰øÆÈ£æÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                } else {
                    const data = `${type} ${key}\n`;
    
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log(`Â∑≤ÂÇ≥ÈÄÅÊåâÈçµÔºö${data.trim()}`);
                    } catch (error) {
                        console.error('ÂÇ≥ÈÄÅÊåâÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }
            }
        }
    
        async function handleVisibilityChange() {
            if (document.hidden || document.visibilityState === 'hidden') {
                if (writer) {
                    try {
                        // ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§Âà∞ Arduino
                        await writer.write(new TextEncoder().encode('RELEASE_ALL\n'));
                        console.log('Â∑≤ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§');
                        await releaseAllKeys();
                    } catch (error) {
                        console.error('ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§ÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }
            }
        }
    
        async function sendMouseMovementToArduino(event) {
            if (writer) {
                const rect = video.getBoundingClientRect();
                const videoAspectRatio = video.videoWidth / video.videoHeight;
                const elementAspectRatio = rect.width / rect.height;
    
                let videoDisplayWidth, videoDisplayHeight;
                let offsetX, offsetY;
    
                if (videoAspectRatio > elementAspectRatio) {
                    videoDisplayWidth = rect.width;
                    videoDisplayHeight = rect.width / videoAspectRatio;
                    offsetX = rect.left;
                    offsetY = rect.top + (rect.height - videoDisplayHeight) / 2;
                } else {
                    videoDisplayWidth = rect.height * videoAspectRatio;
                    videoDisplayHeight = rect.height;
                    offsetX = rect.left + (rect.width - videoDisplayWidth) / 2;
                    offsetY = rect.top;
                }
    
                const mouseX = (event.clientX - offsetX);
                const mouseY = (event.clientY - offsetY);
    
                if (mouseX >= 0 && mouseX <= videoDisplayWidth && mouseY >= 0 && mouseY <= videoDisplayHeight) {
                    const relativeX = mouseX / videoDisplayWidth;
                    const relativeY = mouseY / videoDisplayHeight;
    
                    const absoluteX = Math.round((relativeX * 2 - 1) * 32767);
                    const absoluteY = Math.round((relativeY * 2 - 1) * 32767);
    
                    const currentTime = Date.now();
    
                    if (currentTime - lastConsoleLogTime >= 1000) {
                        console.log(`Ë®àÁÆóÂæåÁöÑÁµïÂ∞çÂ∫ßÊ®ôÔºöX=${absoluteX}, Y=${absoluteY}`);
                        lastConsoleLogTime = currentTime;
                    }
    
                    if (lastMouseX !== absoluteX || lastMouseY !== absoluteY) {
                        const data = `MOUSE_MOVE_TO ${absoluteX} ${absoluteY}\n`;
    
                        try {
                            await writer.write(new TextEncoder().encode(data));
                            lastMouseX = absoluteX;
                            lastMouseY = absoluteY;
                        } catch (error) {
                            console.error('ÂÇ≥ÈÄÅÊªëÈº†ÁµïÂ∞ç‰ΩçÁΩÆÊôÇÁôºÁîüÈåØË™§:', error);
                        }
                    }
                }
            }
        }
    
        async function sendMouseClickToArduino(event) {
            if (writer) {
                event.preventDefault();
                const type = event.type === 'mousedown' ? 'MOUSE_DOWN' : 'MOUSE_UP';
                let button = '';
                if (event.button === 0) button = 'LEFT';
                else if (event.button === 1) button = 'MIDDLE';
                else if (event.button === 2) button = 'RIGHT';
    
                const data = `${type} ${button}\n`;
    
                try {
                    await writer.write(new TextEncoder().encode(data));
                    console.log(`Â∑≤ÂÇ≥ÈÄÅÊªëÈº†ÈªûÊìäÔºö${data.trim()}`);
                } catch (error) {
                    console.error('ÂÇ≥ÈÄÅÊªëÈº†ÈªûÊìäÊôÇÁôºÁîüÈåØË™§:', error);
                }
            }
        }
    
        function handleMouseLeave() {
            lastMouseX = null;
            lastMouseY = null;
        }
    
        async function sendCtrlAltDel() {
            if (writer) {
                try {
                    await writer.write(new TextEncoder().encode('KEY_DOWN Control\n'));
                    await writer.write(new TextEncoder().encode('KEY_DOWN Alt\n'));
                    await writer.write(new TextEncoder().encode('KEY_DOWN Delete\n'));
                    await new Promise(resolve => setTimeout(resolve, 100));
                    await writer.write(new TextEncoder().encode('KEY_UP Delete\n'));
                    await writer.write(new TextEncoder().encode('KEY_UP Alt\n'));
                    await writer.write(new TextEncoder().encode('KEY_UP Control\n'));
                    console.log('Â∑≤ÂÇ≥ÈÄÅ Ctrl+Alt+Delete');
                } catch (error) {
                    console.error('ÂÇ≥ÈÄÅ Ctrl+Alt+Delete ÊôÇÁôºÁîüÈåØË™§:', error);
                }
            }
        }
    
        async function toggleWinKey() {
            if (writer) {
                if (pressedModifiers.has('Meta')) {
                    const data = 'KEY_UP Meta\n';
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log('Â∑≤ÈáãÊîæ Win Èçµ');
                        pressedModifiers.delete('Meta');
                        winButton.classList.remove('active');
                    } catch (error) {
                        console.error('ÈáãÊîæ Win ÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                } else {
                    const data = 'KEY_DOWN Meta\n';
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log('Â∑≤Êåâ‰∏ã Win Èçµ');
                        pressedModifiers.add('Meta');
                        winButton.classList.add('active');
                    } catch (error) {
                        console.error('Êåâ‰∏ã Win ÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }
            }
        }

        async function toggleCtrlKey() {
            if (writer) {
                if (pressedModifiers.has('Control')) {
                    const data = 'KEY_UP Control\n';
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log('Â∑≤ÈáãÊîæ Ctrl Èçµ');
                        pressedModifiers.delete('Control');
                        ctrlButton.classList.remove('active');
                    } catch (error) {
                        console.error('ÈáãÊîæ Ctrl ÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                } else {
                    const data = 'KEY_DOWN Control\n';
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log('Â∑≤Êåâ‰∏ã Ctrl Èçµ');
                        pressedModifiers.add('Control');
                        ctrlButton.classList.add('active');
                    } catch (error) {
                        console.error('Êåâ‰∏ã Ctrl ÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }
            }
        }

        async function toggleAltKey() {
            if (writer) {
                if (pressedModifiers.has('Alt')) {
                    const data = 'KEY_UP Alt\n';
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log('Â∑≤ÈáãÊîæ Alt Èçµ');
                        pressedModifiers.delete('Alt');
                        altButton.classList.remove('active');
                    } catch (error) {
                        console.error('ÈáãÊîæ Alt ÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                } else {
                    const data = 'KEY_DOWN Alt\n';
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log('Â∑≤Êåâ‰∏ã Alt Èçµ');
                        pressedModifiers.add('Alt');
                        altButton.classList.add('active');
                    } catch (error) {
                        console.error('Êåâ‰∏ã Alt ÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                    }
                }
            }
        }

        function toggleFnKeys(event) {
            if (!isFnPopupVisible) {
                const buttonRect = fnButton.getBoundingClientRect();
                fnKeysPopup.style.display = 'grid';
                fnKeysPopup.style.top = `${buttonRect.bottom + 5}px`;
                fnKeysPopup.style.left = `${buttonRect.left}px`;
                isFnPopupVisible = true;
                fnButton.classList.add('active');
            } else {
                closeFnPopup();
            }
        }

        function resetPasteStatus() {
            isPasting = false;
            isPausePasting = false;
            currentPasteIndex = 0;
            startPasteButton.disabled = false;
            pasteArea.disabled = false;
            pausePasteButton.textContent = 'Êö´ÂÅú';
            //pasteArea.value = '';  // Ê∏ÖÁ©∫ÊñáÂ≠óÂçÄÂüü
        }

        async function handleFnKeyPress(key) {
            if (writer) {
                try {
                    await writer.write(new TextEncoder().encode(`KEY_DOWN ${key}\n`));
                    await new Promise(resolve => setTimeout(resolve, 50));
                    await writer.write(new TextEncoder().encode(`KEY_UP ${key}\n`));
                    console.log(`Â∑≤ÂÇ≥ÈÄÅÂäüËÉΩÈçµÔºö${key}`);
                } catch (error) {
                    console.error(`ÂÇ≥ÈÄÅÂäüËÉΩÈçµ ${key} ÊôÇÁôºÁîüÈåØË™§:`, error);
                }
            }
            closeFnPopup();
        }

        function closeFnPopup() {
            fnKeysPopup.style.display = 'none';
            isFnPopupVisible = false;
            fnButton.classList.remove('active');
        }

        async function releaseAllModifiers() {
            if (writer) {
                try {
                    // ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§
                    await writer.write(new TextEncoder().encode('RELEASE_ALL\n'));
                    console.log('Â∑≤ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§');
                    pressedModifiers.clear();
                    winButton.classList.remove('active');
                    ctrlButton.classList.remove('active');
                    altButton.classList.remove('active');
                } catch (error) {
                    console.error('ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§ÊôÇÁôºÁîüÈåØË™§:', error);
                }
            }
        }

        async function releaseAllKeys() {
            if (writer) {
                try {
                    // ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§
                    await writer.write(new TextEncoder().encode('RELEASE_ALL\n'));
                    console.log('Â∑≤ÂÇ≥ÈÄÅ RELEASE_ALL ÂëΩ‰ª§');

                    pressedKeys.clear();
                    pressedModifiers.clear();
                    winButton.classList.remove('active');
                    ctrlButton.classList.remove('active');
                    altButton.classList.remove('active');
                } catch (error) {
                    console.error('ÈáãÊîæÊâÄÊúâÊåâÈçµÊôÇÁôºÁîüÈåØË™§:', error);
                }
            }
        }

        async function resetButtonStates() {
            if (pressedModifiers.size > 0) {
                if (writer) {
                    await releaseAllModifiers();
                } else {
                    pressedModifiers.clear();
                    winButton.classList.remove('active');
                    ctrlButton.classList.remove('active');
                    altButton.classList.remove('active');
                }
            }
        }

        connectControllerButton.addEventListener('click', connectController);
        disconnectControllerButton.addEventListener('click', disconnectController);

        // Ë¶ñË®ä‰æÜÊ∫êÂàáÊèõÁöÑÁõ£ËÅΩÂô®
        videoSourceSelect.addEventListener('change', async () => {
            if (videoStream) {
                const selectedDeviceId = videoSourceSelect.value;
                const [width, height] = resolutionSelect.value.split('x').map(Number);

                try {
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: selectedDeviceId },
                            width: { exact: width },
                            height: { exact: height }
                        }
                    });

                    // ÂÅúÊ≠¢ËàäÁöÑË¶ñË®ä‰∏≤ÊµÅ
                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = newStream;
                    video.srcObject = videoStream;

                    // ÂÑ≤Â≠òÈÅ∏ÊìáÁöÑË¶ñË®ä‰æÜÊ∫ê
                    localStorage.setItem('videoSourceId', selectedDeviceId);
                    
                } catch (error) {
                    console.error('ÂàáÊèõË¶ñË®ä‰æÜÊ∫êÂ§±Êïó:', error);
                    alert('ÂàáÊèõË¶ñË®ä‰æÜÊ∫êÂ§±ÊïóÔºåË´ãÈáçË©¶');
                }
            }
        });

        connectCaptureButton.addEventListener('click', startVideoStream);
        disconnectCaptureButton.addEventListener('click', stopVideoStream);

        // Âú®ÈÅ∏ÂèñËß£ÊûêÂ∫¶ÁöÑ‰∏ãÊãâÈÅ∏ÂñÆÂä†ÂÖ•‰∫ã‰ª∂Áõ£ËÅΩ
        resolutionSelect.addEventListener('change', async () => {
            if (videoStream) {
                const [width, height] = resolutionSelect.value.split('x').map(Number);
                const selectedDeviceId = videoSourceSelect.value;

                try {
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: selectedDeviceId },
                            width: { exact: width },
                            height: { exact: height }
                        }
                    });

                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = newStream;
                    video.srcObject = videoStream;
                    
                    localStorage.setItem('resolution', resolutionSelect.value);
                } catch (error) {
                    console.error('ÂàáÊèõËß£ÊûêÂ∫¶Â§±Êïó:', error);
                    alert('ÂàáÊèõËß£ÊûêÂ∫¶Â§±ÊïóÔºåË´ãÈáçË©¶');
                }
            }
        });

        overlay.addEventListener('click', () => {
            overlay.focus();
        });

        overlay.addEventListener('keydown', (event) => {
            if (event.key === 'Tab') {
                event.preventDefault();
                overlay.focus();
            }
        });

        overlay.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });

        document.addEventListener('click', (event) => {
            if (isFnPopupVisible && 
                !fnButton.contains(event.target) && 
                !fnKeysPopup.contains(event.target)) {
                closeFnPopup();
            }
        });

        document.addEventListener('visibilitychange', handleVisibilityChange);
        window.addEventListener('blur', handleVisibilityChange);

        window.addEventListener('blur', closeFnPopup);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                closeFnPopup();
            }
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isPasting) {
                isPasting = false;
                isPausePasting = false;
                alert('ÂàáÊèõÂàÜÈ†ÅÂ∞éËá¥ÊñáÂ≠óÂÇ≥ÈÄÅ‰∏≠Êñ∑');
            }
        });

        window.addEventListener('beforeunload', () => {
            releaseAllKeys();
        });

        window.addEventListener('beforeunload', () => {
            if (isPasting) {
                isPasting = false;
                isPausePasting = false;
            }
        });

        // Âú®È†ÅÈù¢ËºâÂÖ•ÊôÇÈ°ØÁ§∫ÊñáÂ≠ó
        window.addEventListener('load', () => {
            document.getElementById('noVideoText').style.display = 'block';
        });

        window.addEventListener('load', async () => {
            try {
                // ‰∏ªÂãïË´ãÊ±ÇË¶ñË®äÊ¨äÈôê
                await navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        // ÂèñÂæóÊ¨äÈôêÂæåÁ´ãÂç≥ÂÅúÊ≠¢ stream
                        stream.getTracks().forEach(track => track.stop());
                    });
            } catch (error) {
                console.error('Ë´ãÊ±ÇË¶ñË®äÊ¨äÈôêÂ§±Êïó:', error);
            }

            screenshotButton.addEventListener('click', takeScreenshot);
            startRecordButton.addEventListener('click', startRecording);
            stopRecordButton.addEventListener('click', stopRecording);

            await getVideoSources();

            overlay.tabIndex = 0;
            overlay.style.outline = 'none';

            overlay.addEventListener('keydown', checkControllerAndHighlight);
            overlay.addEventListener('mousedown', checkControllerAndHighlight);
            overlay.addEventListener('contextmenu', checkControllerAndHighlight);

            video.addEventListener('loadedmetadata', () => {
                console.log('Ë¶ñË®ä‰∏≠ÁπºË≥áÊñôÂ∑≤ËºâÂÖ•');
            });
        });


    </script>

</body>
</html>