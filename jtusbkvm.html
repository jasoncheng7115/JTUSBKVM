<!DOCTYPE html>
<!-- 

=========================================================================

JTUSBKVM - Web Console

Version: 1.0.0
Last Update: 2024-11-18

Author: Jason Cheng
E-mail: jason@jason.tools
GitHub: https://github.com/jasoncheng7115

License: GNU Affero General Public License v3.0
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
any later version.

=========================================================================

-->
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>JTUSBKVM - Jason Tools</title>
    <link rel="icon" type="image/png" sizes="512x512" href="logo-1.png">
    <style>
        *, *::before, *::after {
            box-sizing: border-box;
        }
        body, html {
            height: 100%;
            margin: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #header {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            background: #f0f0f0;
            padding: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-shrink: 0;
            min-height: 50px;
        }
        #titleContainer {
            display: flex;
            align-items: center;
            margin-bottom: 0;
        }
        #logo {
            height: 32px;
            margin-right: 10px;
        }
        #title {
            font-weight: bold;
        }
        #controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 5px;
        }
        #rightControls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 5px;
        }
        #videoContainer {
            flex-grow: 1;
            position: relative;
            background: black;
            overflow: hidden; /* æ”¹ç‚º hidden ä»¥é¿å…æ²è»¸ */
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        video {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            transition: width 0.3s, height 0.3s;
            display: block;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            outline: none;
            cursor: crosshair;
        }
        select, button, input[type="text"] {
            height: 28px;
            line-height: 1;
            padding: 0 8px;
            margin: 0;
            vertical-align: middle;
            font-size: 12px;
            border: 1px solid #000;
            border-radius: 0;
            background-color: #e0e0e0;
            transition: background-color 0.3s, transform 0.1s, box-shadow 0.3s;
            cursor: pointer;
        }
        button:hover, input[type="text"]:hover {
            background-color: #b0b0b0;
        }
        @keyframes buttonHighlight {
            0% { background-color: #e0e0e0; }
            50% { background-color: #ff9999; }
            100% { background-color: #e0e0e0; }
        }
        .highlight-button {
            animation: buttonHighlight 1s ease-in-out 3;  /* é–ƒçˆ 3 æ¬¡ */
        }
        .tooltip {
            position: absolute;
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1000;
            animation: fadeInOut 3s ease-in-out;
            white-space: nowrap;
        }

        .tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 0 8px 8px 8px;
            border-style: solid;
            border-color: transparent transparent #333 transparent;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; }
            15% { opacity: 1; }
            85% { opacity: 1; }
            100% { opacity: 0; }
        }        
        .toggle-button:hover {
            background-color: #909090;
        }
        .toggle-button.active:hover {
            background-color: #555555;
        }
        button:active, .toggle-button:active, input[type="text"]:active {
            transform: scale(0.98);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-button {
            background-color: #e0e0e0;
        }
        .toggle-button.active {
            background-color: #a0a0a0;
            color: white;
        }
        button:disabled, input[type="text"]:disabled {
            opacity: 0.5;
            border-color: #ccc;
            cursor: not-allowed;
        }
        .separator {
            height: 28px;
            margin: 0 5px;
            border-left: 1px solid #ccc;
        }
        .control-label {
            line-height: 28px;
            margin: 0;
            padding: 0 5px;
            font-weight: bold;
            font-size: 12px;
        }
        #fnKeysPopup {
            display: none;
            position: absolute;
            background: #f0f0f0;
            border: 1px solid #000;
            padding: 10px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }
        #fnKeysPopup button {
            padding: 5px 10px;
            margin: 0;
            width: 100%;
        }
        #noVideoText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            display: none;
        }
        #recordingTime {
            display: none;
            margin: 0 8px;
            font-family: monospace;
            font-size: 12px;
            line-height: 28px;
            color: #ff0000;
            font-weight: bold;
            min-width: 70px;
        }
        #video:not([src]):not([srcObject]) + #overlay + #noVideoText {
            display: block;
        }
        @media (max-width: 600px) {
            #controls {
                flex-direction: column;
                align-items: flex-start;
            }
            #rightControls {
                flex-direction: column;
                align-items: flex-start;
            }
            .separator {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="header">
        <div id="titleContainer">
            <img id="logo" src="logo-1.png" alt="Logo">
            <div id="title">JTUSBKVM</div>
        </div>
        <div id="controls">
            <span class="control-label">æ§åˆ¶</span>
            <button id="connectController">ğŸŸ¢ é€£æ¥</button>
            <button id="disconnectController" disabled>ğŸ”´ ä¸­æ–·</button>
            <button id="ctrlAltDelButton" disabled>Ctrl+Alt+Delete</button>
            <button id="fnButton" class="toggle-button" disabled>Fn</button>
            <button id="winButton" class="toggle-button" disabled>Win</button>
            <button id="ctrlButton" class="toggle-button" disabled>Ctrl</button>
            <button id="altButton" class="toggle-button" disabled>Alt</button>
            <button id="releaseAllModifiers" class="toggle-button" disabled>ğŸ”„ é‡‹æ”¾</button>
            <button id="pasteText" disabled>ğŸ“‹ è²¼ä¸Š</button>
            <div class="separator"></div>
            <div id="rightControls">
                <span class="control-label">è¦–è¨Š</span>
                <select id="videoSource"></select>
                <select id="resolution">
                    <option value="800x600">800x600</option>
                    <option value="1024x768">1024x768</option>
                    <option value="1280x720">1280x720</option>
                    <option value="1366x768">1366x768</option>
                    <option value="1920x1080">1920x1080</option>
                </select>
                <button id="connectCapture">â–¶ï¸ é€£æ¥</button>
                <button id="disconnectCapture" disabled>â¹ï¸ ä¸­æ–·</button>
                <button id="screenshot" disabled>ğŸ–¼ï¸ æ“·åœ–</button>
                <button id="startRecord" disabled>ğŸ”´ éŒ„å½±</button>
                <span id="recordingTime" style="display: none;">00:00:00</span>
                <button id="stopRecord" disabled>â¬› åœæ­¢</button>
            </div>
        </div>
    </div>

    <div id="fnKeysPopup">
        <button class="fn-key" data-key="F1">F1</button>
        <button class="fn-key" data-key="F2">F2</button>
        <button class="fn-key" data-key="F3">F3</button>
        <button class="fn-key" data-key="F4">F4</button>
        <button class="fn-key" data-key="F5">F5</button>
        <button class="fn-key" data-key="F6">F6</button>
        <button class="fn-key" data-key="F7">F7</button>
        <button class="fn-key" data-key="F8">F8</button>
        <button class="fn-key" data-key="F9">F9</button>
        <button class="fn-key" data-key="F10">F10</button>
        <button class="fn-key" data-key="F11">F11</button>
        <button class="fn-key" data-key="F12">F12</button>
    </div>

    <div id="pasteDialog" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
    background: white; padding: 20px; border: 1px solid #000; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 1000; 
    min-width: 500px; max-width: 80%;">
        <div style="margin-bottom: 10px; font-weight: bold;">æ–‡å­—å‚³é€å·¥å…·</div>
        <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-left: 4px solid #004085; font-size: 14px;">
            <p style="margin: 0 0 8px 0;">æ­¤å·¥å…·æœƒæ¨¡æ“¬éµç›¤åœ¨ç›®æ¨™é›»è…¦ä¸Šé€å­—è¼¸å…¥æ–‡å­—ã€‚</p>
            <p style="margin: 0 0 8px 0;">æ”¯æ´å…§å®¹ï¼š</p>
            <ul style="margin: 0 0 8px 20px; padding: 0;">
                <li>è‹±æ–‡å­—æ¯ï¼ˆå¤§å°å¯«ï¼‰</li>
                <li>æ•¸å­—</li>
                <li>æ¨™é»ç¬¦è™Ÿ</li>
                <li>ç©ºæ ¼å’Œæ›è¡Œ</li>
            </ul>
            <p style="margin: 0; color: #dc3545;">æ³¨æ„ï¼šä¸æ”¯æ´ä¸­æ–‡ã€æ—¥æ–‡ã€éŸ“æ–‡ç­‰éè‹±æ–‡å­—å…ƒ</p>
        </div>
        <div style="margin-bottom: 10px;">è«‹è²¼ä¸Šè¦å‚³é€çš„æ–‡å­—ï¼š</div>
        <textarea id="pasteArea" rows="10" cols="50" style="width: 100%; margin-bottom: 10px; padding: 8px;"></textarea>
        <div id="pasteProgress" style="display: none; margin-bottom: 10px; padding: 8px; background: #e9ecef;">
            é€²åº¦ï¼š<span id="pasteStatus">0</span>/<span id="pasteTotal">0</span> 
            (<span id="pastePercent">0</span>%)
        </div>
        <div style="display: flex; gap: 10px;">
            <button id="startPaste" style="padding: 5px 15px;">é–‹å§‹å‚³é€</button>
            <button id="pausePaste" style="padding: 5px 15px;">æš«åœ</button>
            <button id="cancelPaste" style="padding: 5px 15px;">å–æ¶ˆ</button>
        </div>
    </div>

    <div id="videoContainer">
        <video id="video" autoplay muted></video>
        <div id="overlay" tabindex="0"></div>
        <div id="noVideoText">å°šæœªé€£æ¥è¦–è¨Šä¾†æº</div>   
    </div>

    <script>
        const connectControllerButton = document.getElementById('connectController');
        const disconnectControllerButton = document.getElementById('disconnectController');
        const connectCaptureButton = document.getElementById('connectCapture');
        const disconnectCaptureButton = document.getElementById('disconnectCapture');
        const video = document.getElementById('video');
        const videoSourceSelect = document.getElementById('videoSource');
        const resolutionSelect = document.getElementById('resolution');
        const overlay = document.getElementById('overlay');
        const ctrlAltDelButton = document.getElementById('ctrlAltDelButton');
        const winButton = document.getElementById('winButton');
        const ctrlButton = document.getElementById('ctrlButton');
        const altButton = document.getElementById('altButton');
        const fnButton = document.getElementById('fnButton');
        const releaseAllModifiersButton = document.getElementById('releaseAllModifiers');
        const fnKeysPopup = document.getElementById('fnKeysPopup');
        const screenshotButton = document.getElementById('screenshot');
        const startRecordButton = document.getElementById('startRecord');
        const stopRecordButton = document.getElementById('stopRecord');
        const recordingTimeDisplay = document.getElementById('recordingTime');
        const pressedModifiers = new Set();
        const modifierKeys = {
            ControlLeft: 'Control',
            ControlRight: 'Control',
            AltLeft: 'Alt',
            AltRight: 'Alt',
            MetaLeft: 'Meta',
            MetaRight: 'Meta',
            ShiftLeft: 'Shift',
            ShiftRight: 'Shift'
        };
        const pressedKeys = new Set();   
        const pasteTextButton = document.getElementById('pasteText');
        const pasteDialog = document.getElementById('pasteDialog');
        const pasteArea = document.getElementById('pasteArea');
        const startPasteButton = document.getElementById('startPaste');
        const pausePasteButton = document.getElementById('pausePaste');
        const cancelPasteButton = document.getElementById('cancelPaste');
        const pasteProgress = document.getElementById('pasteProgress');
        const pasteStatus = document.getElementById('pasteStatus');
        const pasteTotal = document.getElementById('pasteTotal');
        const pastePercent = document.getElementById('pastePercent');
        const keyboardMap = {
            'a': 'KeyA', 'b': 'KeyB', 'c': 'KeyC', 'd': 'KeyD', 'e': 'KeyE',
            'f': 'KeyF', 'g': 'KeyG', 'h': 'KeyH', 'i': 'KeyI', 'j': 'KeyJ',
            'k': 'KeyK', 'l': 'KeyL', 'm': 'KeyM', 'n': 'KeyN', 'o': 'KeyO',
            'p': 'KeyP', 'q': 'KeyQ', 'r': 'KeyR', 's': 'KeyS', 't': 'KeyT',
            'u': 'KeyU', 'v': 'KeyV', 'w': 'KeyW', 'x': 'KeyX', 'y': 'KeyY',
            'z': 'KeyZ',
            '1': 'Digit1', '2': 'Digit2', '3': 'Digit3', '4': 'Digit4', '5': 'Digit5',
            '6': 'Digit6', '7': 'Digit7', '8': 'Digit8', '9': 'Digit9', '0': 'Digit0',
            '-': 'Minus', '=': 'Equal',
            '[': 'BracketLeft', ']': 'BracketRight',
            '\\': 'Backslash',
            ';': 'Semicolon', "'": 'Quote',
            ',': 'Comma', '.': 'Period',
            '/': 'Slash', '`': 'Backquote',
            ' ': 'Space'
        };
        const needsShift = new Set([
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
            '~', '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+',
            '{', '}', '|', ':', '"', '<', '>', '?'
        ]);
        const WHEEL_DELAY = 50; // å»¶é² 50ms

        let videoStream;
        let port;
        let writer;
        let isPasting = false;
        let isPausePasting = false;
        let currentPasteIndex = 0;
        let textToSend = '';
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingTimer = null;
        let recordingStartTime = null;
        let keyEventListener = null;
        let mouseMoveListener = null;
        let mouseClickListener = null; 
        let lastMouseX = null;
        let lastMouseY = null;
        let lastConsoleLogTime = 0;
        let isFnPopupVisible = false;
        let lastWheelTime = 0;

        async function sendCtrlAltDel() {
            if (writer) {
                try {
                    // ç›´æ¥å‚³é€ç‰¹å®šçš„ Ctrl+Alt+Del å‘½ä»¤
                    await writer.write(new TextEncoder().encode('CTRL_ALT_DEL\n'));
                    console.log('å·²å‚³é€ Ctrl+Alt+Delete å‘½ä»¤');
                } catch (error) {
                    console.error('å‚³é€ Ctrl+Alt+Delete æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
        }

        // æ“·åœ–åŠŸèƒ½
        async function takeScreenshot() {
            if (video.srcObject) {
                try {
                    // å»ºç«‹ canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    // åœ¨ canvas ä¸Šç¹ªè£½ç›®å‰è¦–è¨Šç•«é¢
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // è½‰æ›ç‚º blob
                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/png');
                    });
                    
                    // å»ºç«‹ä¸‹è¼‰é€£çµ
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `screenshot_${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('æ“·åœ–æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    alert('æ“·åœ–å¤±æ•—ï¼Œè«‹é‡è©¦');
                }
            }
        }


        // æª¢æŸ¥æ˜¯å¦åŒ…å«ä¸­æ—¥éŸ“æ–‡å­—
        function containsCJK(text) {
            // Unicode ç¯„åœï¼š
            // ä¸­æ–‡ï¼š\u4e00-\u9fff
            // æ—¥æ–‡å‡åï¼š\u3040-\u309f\u30a0-\u30ff
            // éŸ“æ–‡ï¼š\uac00-\ud7af\u1100-\u11ff
            const cjkRegex = /[\u4e00-\u9fff\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af\u1100-\u11ff]/;
            return cjkRegex.test(text);
        }


        // é–‹å§‹éŒ„å½±
        function startRecording() {
            try {
                recordedChunks = [];
                const options = { 
                    mimeType: 'video/mp4;codecs=h264,aac'  // å˜—è©¦ä½¿ç”¨ MP4
                };

                // å¦‚æœç€è¦½å™¨ä¸æ”¯æ´ MP4 éŒ„è£½ï¼Œå›åˆ° WebM
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    console.log('MP4 æ ¼å¼ä¸æ”¯æ´ï¼Œä½¿ç”¨ WebM');
                    options.mimeType = 'video/webm;codecs=vp9';
                }

                mediaRecorder = new MediaRecorder(video.srcObject, options);
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = saveRecording;
                
                mediaRecorder.start();
                startRecordButton.disabled = true;
                stopRecordButton.disabled = false;
                console.log('é–‹å§‹éŒ„å½±');
            } catch (error) {
                console.error('é–‹å§‹éŒ„å½±æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                alert('é–‹å§‹éŒ„å½±å¤±æ•—ï¼Œè«‹é‡è©¦');
            }
        }


        function highlightConnectController() {
            if (!connectControllerButton.classList.contains('highlight-button')) {
                
                // å¢åŠ é–ƒçˆæ•ˆæœ
                connectControllerButton.classList.add('highlight-button');
                
                // å»ºç«‹æç¤ºæ¡†
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.textContent = 'è«‹å…ˆé€£æ¥æ§åˆ¶å™¨æ‰èƒ½ä½¿ç”¨éµç›¤æ»‘é¼ åŠŸèƒ½ï¼';
                
                // è¨ˆç®—ä½ç½®
                const buttonRect = connectControllerButton.getBoundingClientRect();
                tooltip.style.left = `${buttonRect.left + (buttonRect.width / 2)}px`;
                tooltip.style.top = `${buttonRect.bottom + 10}px`;
                tooltip.style.transform = 'translateX(-50%)';
                
                // åŠ å…¥åˆ° body ä¸­
                document.body.appendChild(tooltip);
                
                // è¨­å®šæ™‚å™¨ç§»é™¤æ•ˆæœ
                setTimeout(() => {
                    connectControllerButton.classList.remove('highlight-button');
                    document.body.removeChild(tooltip);
                }, 3000);
            }
        }

        function checkControllerAndHighlight(event) {
            if (!port && video.srcObject) {  // å¦‚æœæ²’æœ‰é€£æ¥æ§åˆ¶å™¨ä½†æœ‰è¦–è¨Š
                event.preventDefault();  // é˜»æ­¢é è¨­è¡Œç‚º
                highlightConnectController();
            }
        }

        function updateRecordingTime() {
            const elapsedTime = Date.now() - recordingStartTime;
            const totalSeconds = Math.floor(elapsedTime / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            recordingTimeDisplay.textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // åœæ­¢éŒ„å½±
        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                startRecordButton.disabled = false;
                stopRecordButton.disabled = true;
                // åœæ­¢è¨ˆæ™‚å™¨æœƒåœ¨ mediaRecorder.onstop ä¸­è™•ç†
                console.log('åœæ­¢éŒ„å½±');
            }
        }

        // å„²å­˜éŒ„å½±
        function saveRecording() {
            try {
                const mimeType = mediaRecorder.mimeType;
                const blob = new Blob(recordedChunks, { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // åˆ¤æ–·æª”æ¡ˆæ ¼å¼
                const fileExt = mimeType.includes('mp4') ? 'mp4' : 'webm';
                a.download = `recording_${new Date().toISOString().replace(/[:.]/g, '-')}.${fileExt}`;
                
                if (fileExt === 'webm') {
                    alert('ç”±æ–¼ç€è¦½å™¨é™åˆ¶ï¼Œå½±ç‰‡å·²å„²å­˜ç‚º WebM æ ¼å¼ã€‚å¦‚éœ€ MP4 æ ¼å¼ï¼Œè«‹ä½¿ç”¨å½±ç‰‡è½‰æª”è»Ÿé«”é€²è¡Œè½‰æ›ã€‚');
                }
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                recordedChunks = [];
            } catch (error) {
                console.error('å„²å­˜éŒ„å½±æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                alert('å„²å­˜éŒ„å½±å¤±æ•—ï¼Œè«‹é‡è©¦');
            }
        }

        function stopVideoStream() {
            if (videoStream) {
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    stopRecording();
                    clearInterval(recordingTimer);
                    recordingTimeDisplay.style.display = 'none';
                }
                videoStream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                videoStream = null;
                document.getElementById('noVideoText').style.display = 'block';
            }
            connectCaptureButton.disabled = false;
            disconnectCaptureButton.disabled = true;
            screenshotButton.disabled = true;       
            startRecordButton.disabled = true;      
            stopRecordButton.disabled = true;       
            pasteTextButton.disabled = true;
        }

        async function getVideoSources() {
            try {
                // å…ˆè«‹æ±‚æ¬Šé™
                await navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        // å–å¾—æ¬Šé™å¾Œç«‹å³åœæ­¢stream
                        stream.getTracks().forEach(track => track.stop());
                    });
                    
                // ä¹‹å¾Œå†åˆ—èˆ‰è¨­å‚™
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');

                videoSourceSelect.innerHTML = videoDevices.map(device => {
                    let label = device.label || 'è¦–è¨Šä¾†æº';
                    label = label.replace(/\(.*?\)/g, '').trim();
                    return `<option value="${device.deviceId}">${label}</option>`;
                }).join('');

                const savedVideoSource = localStorage.getItem('videoSourceId');
                const savedResolution = localStorage.getItem('resolution');

                if (savedVideoSource && videoDevices.some(device => device.deviceId === savedVideoSource)) {
                    videoSourceSelect.value = savedVideoSource;
                }

                if (savedResolution) {
                    resolutionSelect.value = savedResolution;
                }
            } catch (error) {
                console.error('å–å¾—è¦–è¨Šä¾†æºæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                alert('è«‹å…è¨±è¦–è¨Šæ¬Šé™ä»¥ä½¿ç”¨æ­¤åŠŸèƒ½');
            }
        }

        async function startVideoStream() {
            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
            }
            const selectedDeviceId = videoSourceSelect.value;
            const [width, height] = resolutionSelect.value.split('x').map(Number);

            const constraints = {
                video: {
                    deviceId: { exact: selectedDeviceId },
                    width: { exact: width },
                    height: { exact: height }
                    }
                };

                try {
                    videoStream = await navigator.mediaDevices.getUserMedia(constraints);
                    video.srcObject = videoStream;
                    document.getElementById('noVideoText').style.display = 'none'; 

                    video.onloadedmetadata = () => {
                        connectCaptureButton.disabled = true;
                        disconnectCaptureButton.disabled = false;
                        screenshotButton.disabled = false;      
                        startRecordButton.disabled = false;     
                        stopRecordButton.disabled = true;       

                        localStorage.setItem('videoSourceId', selectedDeviceId);
                        localStorage.setItem('resolution', resolutionSelect.value);

                    };
                } catch (error) {
                    console.error('é–‹å§‹è¦–è¨Šä¸²æµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    // é¡¯ç¤ºæ›´å‹å–„çš„éŒ¯èª¤è¨Šæ¯
                    if (error.name === 'NotAllowedError') {
                        alert('è«‹å…è¨±è¦–è¨Šæ¬Šé™ä»¥ä½¿ç”¨æ­¤åŠŸèƒ½');
                    } else if (error.name === 'NotFoundError') {
                        alert('æ‰¾ä¸åˆ°æŒ‡å®šçš„è¦–è¨Šè£ç½®');
                    } else if (error.name === 'NotReadableError') {
                        alert('ç„¡æ³•å­˜å–è¦–è¨Šè£ç½®ï¼Œå¯èƒ½è¢«å…¶ä»–ç¨‹å¼ä½”ç”¨');
                    } else {
                        alert('è¦–è¨Šå•Ÿå‹•å¤±æ•—ï¼š' + error.message);
                    }
                }
            }
            
    
        async function connectController() {
            
            // æª¢æŸ¥æ˜¯å¦å·²é€£æ¥è¦–è¨Š
            if (!videoStream) {
                // å–æ¶ˆåŸæœ¬çš„é€£æ¥å‹•ä½œ
                highlightConnectCapture();
                return;
            }
            
            if ('serial' in navigator) {
                try {
                    port = await navigator.serial.requestPort();
                    await port.open({ baudRate: 115200 });
    
                    connectControllerButton.disabled = true;
                    disconnectControllerButton.disabled = false;
    
                    writer = port.writable.getWriter();
    
                    addEventListeners();
                    overlay.focus();
    
                    ctrlAltDelButton.disabled = false;
                    winButton.disabled = false;
                    ctrlButton.disabled = false;
                    altButton.disabled = false;
                    fnButton.disabled = false;
                    releaseAllModifiersButton.disabled = false;
                    pasteTextButton.disabled = false;  
    
                } catch (error) {
                    console.error('é€£æ¥æ§åˆ¶å™¨æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            } else {
                alert('æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´ Web Serial API');
            }
        }
    
        async function disconnectController() {
            if (writer) {
                try {
                    // ä¸­æ–·å‰å‚³é€ RELEASE_ALL
                    await writer.write(new TextEncoder().encode('RELEASE_ALL\n'));
                } catch (error) {
                    console.error('å‚³é€ RELEASE_ALL å‘½ä»¤æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
                writer.releaseLock();
                writer = null;
            }
    
            if (port) {
                await port.close();
                port = null;
            }
    
            connectControllerButton.disabled = false;
            disconnectControllerButton.disabled = true;
    
            removeEventListeners();
            await resetButtonStates();
    
            ctrlAltDelButton.disabled = true;
            winButton.disabled = true;
            ctrlButton.disabled = true;
            altButton.disabled = true;
            fnButton.disabled = true;
            releaseAllModifiersButton.disabled = true;
            pasteTextButton.disabled = true;
    
            closeFnPopup();
            lastMouseX = null;
            lastMouseY = null;
        }
    
        function addEventListeners() {
            keyEventListener = (event) => sendKeyToArduino(event);
            overlay.addEventListener('keydown', keyEventListener);
            overlay.addEventListener('keyup', keyEventListener);
    
            mouseMoveListener = (event) => sendMouseMovementToArduino(event);
            overlay.addEventListener('mousemove', mouseMoveListener);
    
            mouseClickListener = (event) => sendMouseClickToArduino(event);
            overlay.addEventListener('mousedown', mouseClickListener);
            overlay.addEventListener('mouseup', mouseClickListener);
            
            overlay.addEventListener('wheel', handleMouseWheel);

           
            ctrlAltDelButton.addEventListener('click', sendCtrlAltDel);
            winButton.addEventListener('click', toggleWinKey);
            ctrlButton.addEventListener('click', toggleCtrlKey);
            altButton.addEventListener('click', toggleAltKey);
            fnButton.addEventListener('click', toggleFnKeys);
            releaseAllModifiersButton.addEventListener('click', releaseAllModifiers);
    
            pasteTextButton.addEventListener('click', () => {
                pasteDialog.style.display = 'block';
                pasteArea.value = '';
                pasteProgress.style.display = 'none';
                isPasting = false;
                isPausePasting = false;
            });

            cancelPasteButton.addEventListener('click', () => {
                pasteDialog.style.display = 'none';
                if (isPasting) {
                    isPasting = false;
                    isPausePasting = false;
                }
            });

            pausePasteButton.addEventListener('click', () => {
                if (isPasting) {
                    isPausePasting = !isPausePasting;
                    pausePasteButton.textContent = isPausePasting ? 'ç¹¼çºŒ' : 'æš«åœ';
                }
            });

            startPasteButton.addEventListener('click', async () => {
                if (!writer) {
                    alert('è«‹å…ˆé€£æ¥æ§åˆ¶å™¨');
                    return;
                }

                textToSend = pasteArea.value;
                if (!textToSend) {
                    alert('è«‹è¼¸å…¥è¦å‚³é€çš„æ–‡å­—');
                    return;
                }

                // æª¢æŸ¥æ˜¯å¦åŒ…å«ä¸­æ—¥éŸ“æ–‡å­—
                if (containsCJK(textToSend)) {
                    if (!confirm('æª¢æ¸¬åˆ°æ–‡å­—ä¸­åŒ…å«ä¸­æ–‡ã€æ—¥æ–‡æˆ–éŸ“æ–‡å­—å…ƒï¼Œé€™äº›å­—å…ƒå°‡ç„¡æ³•æ­£ç¢ºå‚³é€ã€‚\n\nè¦ç¹¼çºŒå‚³é€å—ï¼Ÿï¼ˆä¸æ”¯æ´çš„å­—å…ƒå°‡è¢«è·³éï¼‰')) {
                        return;
                    }
                }

                if (!isPasting) {
                    isPasting = true;
                    currentPasteIndex = 0;
                    pasteProgress.style.display = 'block';
                    pasteTotal.textContent = textToSend.length;
                    startPasteButton.disabled = true;
                    pasteArea.disabled = true;

                    sendTextByChar();
                }
            });

            overlay.addEventListener('mouseleave', handleMouseLeave);
    
            document.querySelectorAll('.fn-key').forEach(button => {
                button.addEventListener('click', () => {
                    handleFnKeyPress(button.dataset.key);
                });
            });

        }

        // è¦–è¨Šé€£æ¥æŒ‰éˆ•çš„æç¤ºå‡½æ•¸
        function highlightConnectCapture() {
            if (!connectCaptureButton.classList.contains('highlight-button')) {
                // å¢åŠ é–ƒçˆæ•ˆæœ
                connectCaptureButton.classList.add('highlight-button');
                
                // å»ºç«‹æç¤ºæ¡†
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.textContent = 'è«‹å…ˆé€£æ¥è¦–è¨Šç•«é¢ï¼Œå†é€£æ¥æ§åˆ¶å™¨ï¼';
                
                // è¨ˆç®—ä½ç½®
                const buttonRect = connectCaptureButton.getBoundingClientRect();
                tooltip.style.left = `${buttonRect.left + (buttonRect.width / 2)}px`;
                tooltip.style.top = `${buttonRect.bottom + 10}px`;
                tooltip.style.transform = 'translateX(-50%)';
                
                // åŠ å…¥åˆ° body ä¸­
                document.body.appendChild(tooltip);
                
                // è¨­å®šæ™‚å™¨ç§»é™¤æ•ˆæœ
                setTimeout(() => {
                    connectCaptureButton.classList.remove('highlight-button');
                    document.body.removeChild(tooltip);
                }, 3000);
            }
        }


        function removeEventListeners() {
            if (keyEventListener) {
                overlay.removeEventListener('keydown', keyEventListener);
                overlay.removeEventListener('keyup', keyEventListener);
                keyEventListener = null;
            }
    
            if (mouseMoveListener) {
                overlay.removeEventListener('mousemove', mouseMoveListener);
                mouseMoveListener = null;
            }
    
            if (mouseClickListener) {
                overlay.removeEventListener('mousedown', mouseClickListener);
                overlay.removeEventListener('mouseup', mouseClickListener);
                mouseClickListener = null;
            }
    
            overlay.removeEventListener('wheel', handleMouseWheel);

            ctrlAltDelButton.removeEventListener('click', sendCtrlAltDel);
            winButton.removeEventListener('click', toggleWinKey);
            ctrlButton.removeEventListener('click', toggleCtrlKey);
            altButton.removeEventListener('click', toggleAltKey);
            fnButton.removeEventListener('click', toggleFnKeys);
            releaseAllModifiersButton.removeEventListener('click', releaseAllModifiers);
       
            overlay.removeEventListener('mouseleave', handleMouseLeave);
    
            document.querySelectorAll('.fn-key').forEach(button => {
                button.removeEventListener('click', () => {
                    handleFnKeyPress(button.dataset.key);
                });
            });
        }

        async function sendTextByChar() {
            if (!isPasting || !writer) {
                resetPasteStatus();
                return;
            }

            if (isPausePasting) {
                setTimeout(sendTextByChar, 100);
                return;
            }

            if (currentPasteIndex >= textToSend.length) {
                resetPasteStatus();
                pasteDialog.style.display = 'none';
                return;
            }

            try {
                const char = textToSend[currentPasteIndex];
                const DELAY = 15; // å»¶é²æ™‚é–“

                async function sendKeyStrokes(keystrokes) {
                    for (const stroke of keystrokes) {
                        await writer.write(new TextEncoder().encode(stroke + '\n'));
                        await new Promise(resolve => setTimeout(resolve, DELAY));
                    }
                }

                function getKeyStrokes(char) {
                    switch (char) {
                        // æ•¸å­—ä¸Šæ–¹çš„ç¬¦è™Ÿ
                        case '!': return ['MOD_DOWN Shift', 'KEY_DOWN Digit1', 'KEY_UP Digit1', 'MOD_UP Shift'];
                        case '@': return ['MOD_DOWN Shift', 'KEY_DOWN Digit2', 'KEY_UP Digit2', 'MOD_UP Shift'];
                        case '#': return ['MOD_DOWN Shift', 'KEY_DOWN Digit3', 'KEY_UP Digit3', 'MOD_UP Shift'];
                        case '$': return ['MOD_DOWN Shift', 'KEY_DOWN Digit4', 'KEY_UP Digit4', 'MOD_UP Shift'];
                        case '%': return ['MOD_DOWN Shift', 'KEY_DOWN Digit5', 'KEY_UP Digit5', 'MOD_UP Shift'];
                        case '^': return ['MOD_DOWN Shift', 'KEY_DOWN Digit6', 'KEY_UP Digit6', 'MOD_UP Shift'];
                        case '&': return ['MOD_DOWN Shift', 'KEY_DOWN Digit7', 'KEY_UP Digit7', 'MOD_UP Shift'];
                        case '*': return ['MOD_DOWN Shift', 'KEY_DOWN Digit8', 'KEY_UP Digit8', 'MOD_UP Shift'];
                        case '(': return ['MOD_DOWN Shift', 'KEY_DOWN Digit9', 'KEY_UP Digit9', 'MOD_UP Shift'];
                        case ')': return ['MOD_DOWN Shift', 'KEY_DOWN Digit0', 'KEY_UP Digit0', 'MOD_UP Shift'];

                        // ç¬¦è™Ÿéµ
                        case '_': return ['MOD_DOWN Shift', 'KEY_DOWN Minus', 'KEY_UP Minus', 'MOD_UP Shift'];
                        case '+': return ['MOD_DOWN Shift', 'KEY_DOWN Equal', 'KEY_UP Equal', 'MOD_UP Shift'];
                        case '{': return ['MOD_DOWN Shift', 'KEY_DOWN BracketLeft', 'KEY_UP BracketLeft', 'MOD_UP Shift'];
                        case '}': return ['MOD_DOWN Shift', 'KEY_DOWN BracketRight', 'KEY_UP BracketRight', 'MOD_UP Shift'];
                        case '|': return ['MOD_DOWN Shift', 'KEY_DOWN Backslash', 'KEY_UP Backslash', 'MOD_UP Shift'];
                        case ':': return ['MOD_DOWN Shift', 'KEY_DOWN Semicolon', 'KEY_UP Semicolon', 'MOD_UP Shift'];
                        case '"': return ['MOD_DOWN Shift', 'KEY_DOWN Quote', 'KEY_UP Quote', 'MOD_UP Shift'];
                        case '<': return ['MOD_DOWN Shift', 'KEY_DOWN Comma', 'KEY_UP Comma', 'MOD_UP Shift'];
                        case '>': return ['MOD_DOWN Shift', 'KEY_DOWN Period', 'KEY_UP Period', 'MOD_UP Shift'];
                        case '?': return ['MOD_DOWN Shift', 'KEY_DOWN Slash', 'KEY_UP Slash', 'MOD_UP Shift'];
                        case '~': return ['MOD_DOWN Shift', 'KEY_DOWN Backquote', 'KEY_UP Backquote', 'MOD_UP Shift'];

                        // æ›è¡Œå’Œä¸€èˆ¬æŒ‰éµ
                        case '\n':
                        case '\r':
                            return ['KEY_DOWN Enter', 'KEY_UP Enter'];

                        default:
                            if (char >= 'A' && char <= 'Z') {
                                return [
                                    'MOD_DOWN Shift',
                                    `KEY_DOWN Key${char}`,
                                    `KEY_UP Key${char}`,
                                    'MOD_UP Shift'
                                ];
                            } else {
                                const keyCode = keyboardMap[char];
                                return keyCode ? [`KEY_DOWN ${keyCode}`, `KEY_UP ${keyCode}`] : [];
                            }
                    }
                }

                const keyStrokes = getKeyStrokes(char);
                if (keyStrokes.length > 0) {
                    await sendKeyStrokes(keyStrokes);
                }

                currentPasteIndex++;
                pasteStatus.textContent = currentPasteIndex;
                pastePercent.textContent = Math.round((currentPasteIndex / textToSend.length) * 100);

                setTimeout(sendTextByChar, DELAY);

            } catch (error) {
                console.error('å‚³é€æ–‡å­—æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                resetPasteStatus();
                alert('å‚³é€æ–‡å­—æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹é‡è©¦');
            }
        }
   

        async function handleMouseWheel(event) {
            if (writer) {
                const now = Date.now();
                if (now - lastWheelTime < WHEEL_DELAY) {
                    return; // å¦‚æœè·é›¢ä¸Šæ¬¡æ²å‹•æ™‚é–“å¤ªè¿‘ï¼Œå¿½ç•¥
                }
                lastWheelTime = now;

                event.preventDefault();
                const scrollAmount = -Math.sign(event.deltaY);
                
                try {
                    const data = `MOUSE_SCROLL ${scrollAmount}\n`;
                    await writer.write(new TextEncoder().encode(data));
                } catch (error) {
                    console.error('å‚³é€æ»‘é¼ æ»¾è¼ªäº‹ä»¶æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
        }

        async function sendKeyToArduino(event) {
            if (writer) {
                overlay.focus();
    
                const type = event.type === 'keydown' ? 'KEY_DOWN' : 'KEY_UP';
                const key = event.code;
    
                if (type === 'KEY_DOWN') {
                    pressedKeys.add(key);
                } else {
                    pressedKeys.delete(key);
                }
    
                if (modifierKeys[key]) {
                    const modifier = modifierKeys[key];
                    const modType = event.type === 'keydown' ? 'MOD_DOWN' : 'MOD_UP';
                    const data = `${modType} ${modifier}\n`;
    
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log(`å·²å‚³é€ä¿®é£¾éµï¼š${data.trim()}`);
                    } catch (error) {
                        console.error('å‚³é€ä¿®é£¾éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                } else {
                    const data = `${type} ${key}\n`;
    
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log(`å·²å‚³é€æŒ‰éµï¼š${data.trim()}`);
                    } catch (error) {
                        console.error('å‚³é€æŒ‰éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                }
            }
        }
    
        async function handleVisibilityChange() {
            if (document.hidden || document.visibilityState === 'hidden') {
                if (writer) {
                    try {
                        // å‚³é€ RELEASE_ALL å‘½ä»¤åˆ° Arduino
                        await writer.write(new TextEncoder().encode('RELEASE_ALL\n'));
                        console.log('å·²å‚³é€ RELEASE_ALL å‘½ä»¤');
                        await releaseAllKeys();
                    } catch (error) {
                        console.error('å‚³é€ RELEASE_ALL å‘½ä»¤æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                }
            }
        }
    
        async function sendMouseMovementToArduino(event) {
            if (writer) {
                const rect = video.getBoundingClientRect();
                const videoAspectRatio = video.videoWidth / video.videoHeight;
                const elementAspectRatio = rect.width / rect.height;
    
                let videoDisplayWidth, videoDisplayHeight;
                let offsetX, offsetY;
    
                if (videoAspectRatio > elementAspectRatio) {
                    videoDisplayWidth = rect.width;
                    videoDisplayHeight = rect.width / videoAspectRatio;
                    offsetX = rect.left;
                    offsetY = rect.top + (rect.height - videoDisplayHeight) / 2;
                } else {
                    videoDisplayWidth = rect.height * videoAspectRatio;
                    videoDisplayHeight = rect.height;
                    offsetX = rect.left + (rect.width - videoDisplayWidth) / 2;
                    offsetY = rect.top;
                }
    
                const mouseX = (event.clientX - offsetX);
                const mouseY = (event.clientY - offsetY);
    
                if (mouseX >= 0 && mouseX <= videoDisplayWidth && mouseY >= 0 && mouseY <= videoDisplayHeight) {
                    const relativeX = mouseX / videoDisplayWidth;
                    const relativeY = mouseY / videoDisplayHeight;
    
                    const absoluteX = Math.round((relativeX * 2 - 1) * 32767);
                    const absoluteY = Math.round((relativeY * 2 - 1) * 32767);
    
                    const currentTime = Date.now();
    
                    if (currentTime - lastConsoleLogTime >= 1000) {
                        console.log(`è¨ˆç®—å¾Œçš„çµ•å°åº§æ¨™ï¼šX=${absoluteX}, Y=${absoluteY}`);
                        lastConsoleLogTime = currentTime;
                    }
    
                    if (lastMouseX !== absoluteX || lastMouseY !== absoluteY) {
                        const data = `MOUSE_MOVE_TO ${absoluteX} ${absoluteY}\n`;
    
                        try {
                            await writer.write(new TextEncoder().encode(data));
                            lastMouseX = absoluteX;
                            lastMouseY = absoluteY;
                        } catch (error) {
                            console.error('å‚³é€æ»‘é¼ çµ•å°ä½ç½®æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                        }
                    }
                }
            }
        }
    
        async function sendMouseClickToArduino(event) {
            if (writer) {
                event.preventDefault();
                const type = event.type === 'mousedown' ? 'MOUSE_DOWN' : 'MOUSE_UP';
                let button = '';
                if (event.button === 0) button = 'LEFT';
                else if (event.button === 1) button = 'MIDDLE';
                else if (event.button === 2) button = 'RIGHT';
    
                const data = `${type} ${button}\n`;
    
                try {
                    await writer.write(new TextEncoder().encode(data));
                    console.log(`å·²å‚³é€æ»‘é¼ é»æ“Šï¼š${data.trim()}`);
                } catch (error) {
                    console.error('å‚³é€æ»‘é¼ é»æ“Šæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
        }
    
        function handleMouseLeave() {
            lastMouseX = null;
            lastMouseY = null;
        }
    
        async function sendCtrlAltDel() {
            if (writer) {
                try {
                    await writer.write(new TextEncoder().encode('KEY_DOWN Control\n'));
                    await writer.write(new TextEncoder().encode('KEY_DOWN Alt\n'));
                    await writer.write(new TextEncoder().encode('KEY_DOWN Delete\n'));
                    await new Promise(resolve => setTimeout(resolve, 100));
                    await writer.write(new TextEncoder().encode('KEY_UP Delete\n'));
                    await writer.write(new TextEncoder().encode('KEY_UP Alt\n'));
                    await writer.write(new TextEncoder().encode('KEY_UP Control\n'));
                    console.log('å·²å‚³é€ Ctrl+Alt+Delete');
                } catch (error) {
                    console.error('å‚³é€ Ctrl+Alt+Delete æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
        }
    
        async function toggleWinKey() {
            if (writer) {
                if (pressedModifiers.has('Meta')) {
                    const data = 'KEY_UP Meta\n';
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log('å·²é‡‹æ”¾ Win éµ');
                        pressedModifiers.delete('Meta');
                        winButton.classList.remove('active');
                    } catch (error) {
                        console.error('é‡‹æ”¾ Win éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                } else {
                    const data = 'KEY_DOWN Meta\n';
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log('å·²æŒ‰ä¸‹ Win éµ');
                        pressedModifiers.add('Meta');
                        winButton.classList.add('active');
                    } catch (error) {
                        console.error('æŒ‰ä¸‹ Win éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                }
            }
        }

        async function toggleCtrlKey() {
            if (writer) {
                if (pressedModifiers.has('Control')) {
                    const data = 'KEY_UP Control\n';
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log('å·²é‡‹æ”¾ Ctrl éµ');
                        pressedModifiers.delete('Control');
                        ctrlButton.classList.remove('active');
                    } catch (error) {
                        console.error('é‡‹æ”¾ Ctrl éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                } else {
                    const data = 'KEY_DOWN Control\n';
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log('å·²æŒ‰ä¸‹ Ctrl éµ');
                        pressedModifiers.add('Control');
                        ctrlButton.classList.add('active');
                    } catch (error) {
                        console.error('æŒ‰ä¸‹ Ctrl éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                }
            }
        }

        async function toggleAltKey() {
            if (writer) {
                if (pressedModifiers.has('Alt')) {
                    const data = 'KEY_UP Alt\n';
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log('å·²é‡‹æ”¾ Alt éµ');
                        pressedModifiers.delete('Alt');
                        altButton.classList.remove('active');
                    } catch (error) {
                        console.error('é‡‹æ”¾ Alt éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                } else {
                    const data = 'KEY_DOWN Alt\n';
                    try {
                        await writer.write(new TextEncoder().encode(data));
                        console.log('å·²æŒ‰ä¸‹ Alt éµ');
                        pressedModifiers.add('Alt');
                        altButton.classList.add('active');
                    } catch (error) {
                        console.error('æŒ‰ä¸‹ Alt éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                    }
                }
            }
        }

        function toggleFnKeys(event) {
            if (!isFnPopupVisible) {
                const buttonRect = fnButton.getBoundingClientRect();
                fnKeysPopup.style.display = 'grid';
                fnKeysPopup.style.top = `${buttonRect.bottom + 5}px`;
                fnKeysPopup.style.left = `${buttonRect.left}px`;
                isFnPopupVisible = true;
                fnButton.classList.add('active');
            } else {
                closeFnPopup();
            }
        }

        function resetPasteStatus() {
            isPasting = false;
            isPausePasting = false;
            currentPasteIndex = 0;
            startPasteButton.disabled = false;
            pasteArea.disabled = false;
            pausePasteButton.textContent = 'æš«åœ';
            //pasteArea.value = '';  // æ¸…ç©ºæ–‡å­—å€åŸŸ
        }

        async function handleFnKeyPress(key) {
            if (writer) {
                try {
                    await writer.write(new TextEncoder().encode(`KEY_DOWN ${key}\n`));
                    await new Promise(resolve => setTimeout(resolve, 50));
                    await writer.write(new TextEncoder().encode(`KEY_UP ${key}\n`));
                    console.log(`å·²å‚³é€åŠŸèƒ½éµï¼š${key}`);
                } catch (error) {
                    console.error(`å‚³é€åŠŸèƒ½éµ ${key} æ™‚ç™¼ç”ŸéŒ¯èª¤:`, error);
                }
            }
            closeFnPopup();
        }

        function closeFnPopup() {
            fnKeysPopup.style.display = 'none';
            isFnPopupVisible = false;
            fnButton.classList.remove('active');
        }

        async function releaseAllModifiers() {
            if (writer) {
                try {
                    // å‚³é€ RELEASE_ALL å‘½ä»¤
                    await writer.write(new TextEncoder().encode('RELEASE_ALL\n'));
                    console.log('å·²å‚³é€ RELEASE_ALL å‘½ä»¤');
                    pressedModifiers.clear();
                    winButton.classList.remove('active');
                    ctrlButton.classList.remove('active');
                    altButton.classList.remove('active');
                } catch (error) {
                    console.error('å‚³é€ RELEASE_ALL å‘½ä»¤æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
        }

        async function releaseAllKeys() {
            if (writer) {
                try {
                    // å‚³é€ RELEASE_ALL å‘½ä»¤
                    await writer.write(new TextEncoder().encode('RELEASE_ALL\n'));
                    console.log('å·²å‚³é€ RELEASE_ALL å‘½ä»¤');

                    pressedKeys.clear();
                    pressedModifiers.clear();
                    winButton.classList.remove('active');
                    ctrlButton.classList.remove('active');
                    altButton.classList.remove('active');
                } catch (error) {
                    console.error('é‡‹æ”¾æ‰€æœ‰æŒ‰éµæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
                }
            }
        }

        async function resetButtonStates() {
            if (pressedModifiers.size > 0) {
                if (writer) {
                    await releaseAllModifiers();
                } else {
                    pressedModifiers.clear();
                    winButton.classList.remove('active');
                    ctrlButton.classList.remove('active');
                    altButton.classList.remove('active');
                }
            }
        }

        connectControllerButton.addEventListener('click', connectController);
        disconnectControllerButton.addEventListener('click', disconnectController);

        // è¦–è¨Šä¾†æºåˆ‡æ›çš„ç›£è½å™¨
        videoSourceSelect.addEventListener('change', async () => {
            if (videoStream) {
                const selectedDeviceId = videoSourceSelect.value;
                const [width, height] = resolutionSelect.value.split('x').map(Number);

                try {
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: selectedDeviceId },
                            width: { exact: width },
                            height: { exact: height }
                        }
                    });

                    // åœæ­¢èˆŠçš„è¦–è¨Šä¸²æµ
                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = newStream;
                    video.srcObject = videoStream;

                    // å„²å­˜é¸æ“‡çš„è¦–è¨Šä¾†æº
                    localStorage.setItem('videoSourceId', selectedDeviceId);
                    
                } catch (error) {
                    console.error('åˆ‡æ›è¦–è¨Šä¾†æºå¤±æ•—:', error);
                    alert('åˆ‡æ›è¦–è¨Šä¾†æºå¤±æ•—ï¼Œè«‹é‡è©¦');
                }
            }
        });

        connectCaptureButton.addEventListener('click', startVideoStream);
        disconnectCaptureButton.addEventListener('click', stopVideoStream);

        // åœ¨é¸å–è§£æåº¦çš„ä¸‹æ‹‰é¸å–®åŠ å…¥äº‹ä»¶ç›£è½
        resolutionSelect.addEventListener('change', async () => {
            if (videoStream) {
                const [width, height] = resolutionSelect.value.split('x').map(Number);
                const selectedDeviceId = videoSourceSelect.value;

                try {
                    const newStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: selectedDeviceId },
                            width: { exact: width },
                            height: { exact: height }
                        }
                    });

                    videoStream.getTracks().forEach(track => track.stop());
                    videoStream = newStream;
                    video.srcObject = videoStream;
                    
                    localStorage.setItem('resolution', resolutionSelect.value);
                } catch (error) {
                    console.error('åˆ‡æ›è§£æåº¦å¤±æ•—:', error);
                    alert('åˆ‡æ›è§£æåº¦å¤±æ•—ï¼Œè«‹é‡è©¦');
                }
            }
        });

        overlay.addEventListener('click', () => {
            overlay.focus();
        });

        overlay.addEventListener('keydown', (event) => {
            if (event.key === 'Tab') {
                event.preventDefault();
                overlay.focus();
            }
        });

        overlay.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });

        document.addEventListener('click', (event) => {
            if (isFnPopupVisible && 
                !fnButton.contains(event.target) && 
                !fnKeysPopup.contains(event.target)) {
                closeFnPopup();
            }
        });

        document.addEventListener('visibilitychange', handleVisibilityChange);
        window.addEventListener('blur', handleVisibilityChange);

        window.addEventListener('blur', closeFnPopup);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                closeFnPopup();
            }
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isPasting) {
                isPasting = false;
                isPausePasting = false;
                alert('åˆ‡æ›åˆ†é å°è‡´æ–‡å­—å‚³é€ä¸­æ–·');
            }
        });

        window.addEventListener('beforeunload', () => {
            releaseAllKeys();
        });

        window.addEventListener('beforeunload', () => {
            if (isPasting) {
                isPasting = false;
                isPausePasting = false;
            }
        });

        // åœ¨é é¢è¼‰å…¥æ™‚é¡¯ç¤ºæ–‡å­—
        window.addEventListener('load', () => {
            document.getElementById('noVideoText').style.display = 'block';
        });

        window.addEventListener('load', async () => {
            try {
                // ä¸»å‹•è«‹æ±‚è¦–è¨Šæ¬Šé™
                await navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        // å–å¾—æ¬Šé™å¾Œç«‹å³åœæ­¢ stream
                        stream.getTracks().forEach(track => track.stop());
                    });
            } catch (error) {
                console.error('è«‹æ±‚è¦–è¨Šæ¬Šé™å¤±æ•—:', error);
            }

            screenshotButton.addEventListener('click', takeScreenshot);
            startRecordButton.addEventListener('click', startRecording);
            stopRecordButton.addEventListener('click', stopRecording);

            await getVideoSources();

            overlay.tabIndex = 0;
            overlay.style.outline = 'none';

            overlay.addEventListener('keydown', checkControllerAndHighlight);
            overlay.addEventListener('mousedown', checkControllerAndHighlight);
            overlay.addEventListener('contextmenu', checkControllerAndHighlight);

            video.addEventListener('loadedmetadata', () => {
                console.log('è¦–è¨Šä¸­ç¹¼è³‡æ–™å·²è¼‰å…¥');
            });
        });


    </script>

</body>
</html>